{
    "version": "https://jsonfeed.org/version/1",
    "title": "Blog • All posts by \"笔者是菜鸟，上课不记笔记，因而只有补天笔记了\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/04/28/mips/",
            "url": "http://example.com/2024/04/28/mips/",
            "title": "计原笔记",
            "date_published": "2024-04-28T09:15:00.000Z",
            "content_html": "<h2 id=\"性能\"><a class=\"markdownIt-Anchor\" href=\"#性能\">#</a> 性能</h2>\n<p 时钟频率=\"\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>性能</mtext><mo>=</mo><mfrac><mn>1</mn><mtext>执行时间</mtext></mfrac></mrow><annotation encoding=\"application/x-tex\">性能=\\frac{1}{执行时间}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">性</span><span class=\"mord cjk_fallback\">能</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.190108em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.845108em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">执</span><span class=\"mord cjk_fallback mtight\">行</span><span class=\"mord cjk_fallback mtight\">时</span><span class=\"mord cjk_fallback mtight\">间</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span><br>\n X 是 Y 的 n 倍快：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mtext>性能</mtext><mi>x</mi></mrow><mrow><mtext>性能</mtext><mi>y</mi></mrow></mfrac><mo>=</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\frac{性能x}{性能y}=n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.3534389999999998em;vertical-align:-0.481108em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.872331em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">性</span><span class=\"mord cjk_fallback mtight\">能</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">y</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">性</span><span class=\"mord cjk_fallback mtight\">能</span><span class=\"mord mathnormal mtight\">x</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.481108em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span><br>\n 我们用 CPU (执行) 时间来反映在 CPU 花费时间，而非 CPU 工作时间<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>程序</mtext><mi>C</mi><mi>P</mi><mi>U</mi><mtext>执行时间</mtext><mo>=</mo><mfrac><mrow><mtext>程序的</mtext><mi>C</mi><mi>P</mi><mi>U</mi><mtext>时钟周期数</mtext></mrow><mtext>时钟频率</mtext></mfrac></mrow><annotation encoding=\"application/x-tex\">程序CPU执行时间=\\frac{程序的CPU时钟周期数}{时钟频率}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">程</span><span class=\"mord cjk_fallback\">序</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord cjk_fallback\">执</span><span class=\"mord cjk_fallback\">行</span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">间</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.217331em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.872331em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">时</span><span class=\"mord cjk_fallback mtight\">钟</span><span class=\"mord cjk_fallback mtight\">频</span><span class=\"mord cjk_fallback mtight\">率</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">程</span><span class=\"mord cjk_fallback mtight\">序</span><span class=\"mord cjk_fallback mtight\">的</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord cjk_fallback mtight\">时</span><span class=\"mord cjk_fallback mtight\">钟</span><span class=\"mord cjk_fallback mtight\">周</span><span class=\"mord cjk_fallback mtight\">期</span><span class=\"mord cjk_fallback mtight\">数</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span><br>\n 提升到原来多少是指原来的多少倍<br>\n CPI 每条指令所需平均时钟周期<br>\nCPU时间=\\frac{指令数*CPI}</p>\n<h1 id=\"指令计算机的语言\"><a class=\"markdownIt-Anchor\" href=\"#指令计算机的语言\">#</a> 指令：计算机的语言</h1>\n<p>32 个寄存器<br>\n 2 <code>**</code> 30 的存储字</p>\n<h3 id=\"数据传送指令\"><a class=\"markdownIt-Anchor\" href=\"#数据传送指令\">#</a> 数据传送指令</h3>\n<p><strong>lw s1,20__\n__sw ` <code>1,20(</code> $`s2)</strong> 值得注意的是，字是 32 位，不同于 x86<br>\n<strong>lh</strong>  半字以及 lhu 半字无符号 ，一个进行符号扩充，一个进行无符号扩充<br>\n<strong> sh</strong><br>\n<strong>lb</strong> 下载一个字节 对应 lbu<br>\n<strong>sb</strong><br>\n<strong>ll</strong> 说是取数，不知道是啥，原子交换第一部分，load linked word<br>\n<strong>sc</strong> store condition word 是上一个的反过来。想起来了，这个是锁的问题。。。</p>\n<h3 id=\"逻辑运算\"><a class=\"markdownIt-Anchor\" href=\"#逻辑运算\">#</a> 逻辑运算</h3>\n<p><strong>and</strong><br>\n<strong>or</strong> 注意这都是 R 型指令<br>\n andi<br>\nsll  shift left logical<br>\nsrl</p>\n<h2 id=\"分支语句\"><a class=\"markdownIt-Anchor\" href=\"#分支语句\">#</a> 分支语句</h2>\n<p><strong>beq .1,.2,50</strong> 这个 pc=50 <code>*</code> 4+4+pc<br>\nbne<br>\nslt .1,.2,.3 set less than 如果.2 小于.3 那么.1 是 1，反之为 0<br>\nsltu<br>\nslti<br>\nsltiu</p>\n<h2 id=\"跳转语句\"><a class=\"markdownIt-Anchor\" href=\"#跳转语句\">#</a> 跳转语句</h2>\n<p>j 2500<br>\njr register<br>\njal 2500 jump and link ra 寄存器存储 pc+4 地址<br>\n <code>#</code> 表示一行的注释</p>\n<h2 id=\"关于寄存器\"><a class=\"markdownIt-Anchor\" href=\"#关于寄存器\">#</a> 关于寄存器</h2>\n<p>大量寄存器可能使时钟周期变长<br>\n字起始地址应该是 4 的倍数，这是对齐限制<br>\n将不常使用的变量存回寄存器叫做寄存器换出<br>\n相比存储器，寄存器吞吐率高，访问时间短<br>\n <code>$s0~$s7</code>  映射到寄存器 16~23<br>\n <code>$t0~$t7</code>  映射到 8~15</p>\n<h2 id=\"指令\"><a class=\"markdownIt-Anchor\" href=\"#指令\">#</a> 指令</h2>\n<table>\n<thead>\n<tr>\n<th>op</th>\n<th>rs</th>\n<th>rt</th>\n<th>rd</th>\n<th>shamt</th>\n<th>funct</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>6 位</td>\n<td>5 位</td>\n<td>5 位</td>\n<td>5 位</td>\n<td>5 位</td>\n<td>6 位</td>\n</tr>\n</tbody>\n</table>\n<p>R 型指令如上 rs 或 rt 可以等于 rd</p>\n<table>\n<thead>\n<tr>\n<th>op</th>\n<th>rs</th>\n<th>rt</th>\n<th>constant/address</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>6 位</td>\n<td>5 位</td>\n<td>5 位</td>\n<td>16 位</td>\n</tr>\n</tbody>\n</table>\n<p>常数绝对值不得超过 2 <code>**</code> 15<br>\n 对应的 op 不知道要不要考，暂且不写</p>\n<p>mips 里面没有 not，但有 nor（或非）not（a or b） <code>nor a，0</code>  就是对 a 取反，xor（异或）<br>\n做运算时，如果是加法（包括无符号加法) 这类，16 位立即数会符号扩充，如果是异或这类，会零扩充</p>\n<h3 id=\"决策指令\"><a class=\"markdownIt-Anchor\" href=\"#决策指令\">#</a> 决策指令</h3>\n<p>beq r1，r2，L1<br>\nbne 这两个叫条件分支<br>\n没有分支目标 / 分支标签的指令序列叫做基本块。编译最初阶段任务是分解基本块出来<br>\n注意没有小于则分支，大于则分支这类说法，因为 slt 可以满足需求 bne</p>\n<h3 id=\"过程\"><a class=\"markdownIt-Anchor\" href=\"#过程\">#</a> 过程</h3>\n<p>过程约定：<br>\na0~a3: 传递参数的四个寄存器<br>\n v0~v1: 返回结果的两个值寄存器<br>\n ra: 返回地址寄存器<br>\n jal 会让下一条指令链接到 ra 上<br>\n PC 全名 program counter 程序计数器<br>\n mips 里的 push 是自己先向下移动 sp，再存入数据在 sp 指向块<br>\n在过程中，t0<sub>t9 随便使用，s0</sub>s7 则需要复原。<br>\n不调用其他过程的过程叫叶过程<br>\n由于再次调用原因，我们每个程序一般都要 push ra 和 a0 的，具体如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addi $sp,-8</span><br><span class=\"line\">sw $ra,4($sp)</span><br><span class=\"line\">sw $a0,0($sp)</span><br><span class=\"line\">之后复原</span><br><span class=\"line\">lw $a0,4($sp)</span><br><span class=\"line\">lw $a0,0(sp)</span><br><span class=\"line\">addi $sp,8</span><br><span class=\"line\">jr $ra</span><br></pre></td></tr></table></figure>\n<p>不过过程不要求保留 a0<sub>a3，要求保留 ra，sp，s0</sub>s7 还有 sp 之上的栈，这些要求不变<br>\n栈中包含过程中所需寄存器和局部变量的片段叫做过程帧或活动记录。帧指针指向一开始 sp 还未保存时的地方</p>\n<h3 id=\"加锁\"><a class=\"markdownIt-Anchor\" href=\"#加锁\">#</a> 加锁</h3>\n<p>交换原语，寄存器把 1 与存储器的 0 交换，视为加锁，如果换出来的是 1，是为解锁失败</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addi $t0,$zero,1</span><br><span class=\"line\">ll $t1,0($s1)</span><br><span class=\"line\">sc $t0,0($t1)//存成返回1，失败返回0，重复循环</span><br></pre></td></tr></table></figure>\n<h1 id=\"运算\"><a class=\"markdownIt-Anchor\" href=\"#运算\">#</a> 运算</h1>\n<h3 id=\"溢出\"><a class=\"markdownIt-Anchor\" href=\"#溢出\">#</a> 溢出</h3>\n<p>add、addi、sub 溢出时会产生异常（也叫中断）（EPC）<br>\n无符号不会溢出，c 语言忽略溢出采用的是无符号<br>\n ALU 算术逻辑单元<br>\n饱和操作指溢出后直接变成最大值<br>\n检测溢出时有符号检测两个数符号和和的符号，无符号检测一个数的取反和和的大小<br>\n $k0 $k1 是用来溢出处理后返回指令地址的</p>\n<h2 id=\"加快乘除法\"><a class=\"markdownIt-Anchor\" href=\"#加快乘除法\">#</a> 加快乘除法</h2>\n<p>这章注意 143 和 138 的图，可能要画的</p>\n<h3 id=\"乘法指令\"><a class=\"markdownIt-Anchor\" href=\"#乘法指令\">#</a> 乘法指令</h3>\n<p>mult multu<br>\nmips 通过 Hi 和 Lo 这两个寄存器存储积，mflo 和 mfhi 可以将积取出，可以通过检查 hi 来判断是否溢出<br>\n可通过并行加快</p>\n<h3 id=\"除法指令\"><a class=\"markdownIt-Anchor\" href=\"#除法指令\">#</a> 除法指令</h3>\n<p>div<br>\ndivu<br>\n 除数开始时置于左 32 位，右移变小，检测是否可以减去，然后判断该位为 0 或 1（通过减后大于 0 小于 0 判断小于则加回去），商左移，末置位不断赋 1 或 0<br>\n 除法的改进版相比于乘法余数向左移（最终存储值)，这是因为控制单元在右边，通过右边产生 0 或 1 来出现商。<br>\n有符号数余数的设置要让商的绝对值不变化，余数应该与被除数的符号相同 (笔者猜测)。</p>\n<blockquote>\n<p>忽略了除数位 0，忽略溢出，通过 hi 和 lo 来判断吧（mflo 和 mfhi）注意余数是 hi</p>\n</blockquote>\n<h2 id=\"浮点运算\"><a class=\"markdownIt-Anchor\" href=\"#浮点运算\">#</a> 浮点运算</h2>\n<p>科学计数法，没有前导零且小数点左边只有一位有效位叫做规格化数。<br>\n二进制数科学计数法<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1.0</mn><mo>∗</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">1.0*2^{-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">.</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> 浮点数表示<br>\n浮点表示：<br>\n注意这个尾数第一位表示的是 0.5，也就是前导位 1 是自带的</p>\n<blockquote>\n<p>前导位 0 的表示是通过把指数位设为 0 来表示的，0 这个数是所有位都为 0 表示<br>\n无穷大数设置指数位最大，尾数为 0，尾数不为 0 则为 NaN（非数（由 0/0 或无穷减无穷产生））</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>s</th>\n<th>exponent</th>\n<th>fraction</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1 位</td>\n<td>8 位</td>\n<td>23 位</td>\n</tr>\n</tbody>\n</table>\n<p>还是可能会出现上溢，在指数级容纳不下，还有下溢，就是指数级 10^(-38) 达不到的地方<br>\n double (两个字大小) 表示，</p>\n<table>\n<thead>\n<tr>\n<th>s</th>\n<th>exponent</th>\n<th>fraction</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1 位</td>\n<td>11 位</td>\n<td>52 位</td>\n</tr>\n</tbody>\n</table>\n<p>精度到达<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>308</mn></msup></mrow><annotation encoding=\"application/x-tex\">2*10^{308}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">0</span><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span></span></span></span><br>\n 采用带偏阶（或移码）记数法（biased notation). 意思是指数的真实值是减去这个 bias，单精度 bias 是 127，双精度是 1023，为啥向下取整我不知道（可能是 255 表示无穷吧，1-254 的指数才是正常指数，但是你看这张图多奇怪<br>\n！[[Pasted image 20241220195351.png]])<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>0.7</mn><msub><mn>5</mn><mn>10</mn></msub></mrow><annotation encoding=\"application/x-tex\">-0.75_{10}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.79444em;vertical-align:-0.15em;\"></span><span class=\"mord\">−</span><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\">7</span><span class=\"mord\"><span class=\"mord\">5</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的单精度格式为 1 01111110 10000000000000000000000</p>\n<h4 id=\"浮点加法\"><a class=\"markdownIt-Anchor\" href=\"#浮点加法\">#</a> 浮点加法</h4>\n<p 10=\"\">会出现保留位的说法，先将指数小的向指数大的对齐，然后舍去到大数所能包容的有效位，有效位此时是规格化科学计数法的有效位，规格化后检查上溢和下溢 (-126~127 其实就是有效指数位)，然后舍成有效位，再规格化，具体计算看 151 和 152 页，注意写的时候注意写清下标是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">_{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.45110799999999995em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 还是_</p>\n<h3 id=\"浮点乘法\"><a class=\"markdownIt-Anchor\" href=\"#浮点乘法\">#</a> 浮点乘法</h3>\n<p>较为简单，自行看 p155，当然尾数乘法就是乘出来的最高位肯定是前导 1</p>\n<h3 id=\"浮点数指令\"><a class=\"markdownIt-Anchor\" href=\"#浮点数指令\">#</a> 浮点数指令</h3>\n<p>add.s（单精度加) add.d（双精度加)<br>\nsub.s sub.d<br>\nmul.s mul.d 莫名没了个 t 也是坑人<br>\n div.s div.d<br>\nc.x.s c.x.s 就是比较 x 可以是 eq、neq、lt、le、gt、ge 感觉不会考，不用 rd 来接受返回值的操作，值存储在浮点标志中<br>\n bclt 和 bclf 真分支跳转和假分支跳转 浮点标志是 c.x.s 这些给出的<br>\n有 $f0, $f1, $f2 这类浮点寄存器，两个寄存器构成一个双精度 0 和 1 构成一个（偶 - 奇搭配) 还有 lwcl 和 swcl ，写到这我就忘了汇编的是啥了。。。。<br>\n注意没有浮点常数，一般直接常数放在内存取出来</p>\n<h3 id=\"浮点数算术精度\"><a class=\"markdownIt-Anchor\" href=\"#浮点数算术精度\">#</a> 浮点数算术精度</h3>\n<p>保护位 (guard) 舍入位 (round) 保护位在前舍入位在后<br>\n保护位原来在这里，有几种舍入策略，round up ,round down ,truncation, 向最近偶数舍入</p>\n<ul>\n<li>保护位舍入，就是看有效位后面两位，0-49 舍去，51-99 入位。<br>\n浮点数精确性由尾数最低位的单位 (ulp)(unit in the last place) 给出，这个方法保证误差在半个 ulp 以内<br>\n粘贴位就是在舍入位后多一位，表示舍入位后是否全为 0，如果不全为 0，则置 1，保护位和舍入位<br>\n运算时这些位都会用到，最后一步才会真正舍去，详情见 p163</li>\n</ul>\n<h1 id=\"处理器\"><a class=\"markdownIt-Anchor\" href=\"#处理器\">#</a> 处理器</h1>\n<p>存储访问指令和算术逻辑指令分支指令通过 ALU 实现<br>\n图得看 p183<br>\n 选择不同来源数据使用多路选择器（multiplexor)。例如决定 pc+4 还是分支目的地址<br>\n控制单元 (control unit)，给出 multiplexor 的选择信号<br>\n mips 数据通路包含两种单元：处理数据值的单元和存储状态的单元<br>\n处理数据值的单元是组合逻辑单元 (conbinational element), 输出只取决于当前输入。ALU 就是这类。<br>\n有内部存储功能的单元是状态单元 (state element) 也叫时序 (sequential) 部件，指令存储器、数据存储器、寄存器都是状态单元。一个状态单元至少有两个输入和一个输出。两个输入时待写入数据值和决定何时写入的时钟信号。</p>\n<h3 id=\"时钟策略\"><a class=\"markdownIt-Anchor\" href=\"#时钟策略\">#</a> 时钟策略</h3>\n<p>采用边沿触发时钟 (edge-triggered clocking) 方法，书上假定上升沿发生变化（也可以下降沿）。 <code>|-|_</code> 这个横线是上划线。。。, 若某状态单元在时钟边沿进行写入，那可以忽略控制信号。如果不是每个周期都进行修改，则要显式的写控制信号。写控制信号和时钟信号都是输入信号，必须稳定等到时钟沿到来才改变状态。<br>\n有效 (asserted) 表示信号为逻辑高或真<br>\n无效 (deasserted) 表示信号为逻辑低或假</p>\n<h3 id=\"建立数据通路\"><a class=\"markdownIt-Anchor\" href=\"#建立数据通路\">#</a> 建立数据通路</h3>\n<p>指令存储器，程序计数器，ALU，加法器（计算 pc，可以用 ALU）<br>\n寄存器堆存放 32 个传统用寄存器。地址偏移还要有个 sign-extend 单元来符号拓展<br>\n注意寄存器堆的输入信号和输出信号同时变换，所以读出同一时钟周期是不可能相互影响到的，所以读出的只会是写入之前的数据，不过可以在末尾读入，也就是一个时钟周期读写嘛</p>\n<p>计算分支指令的基地址是下一条指令的地址。<br>\n分支发生 branch taken 分支未发生 branch not taken<br>\n 跳转指令将 26 位左移 2 位后，代替 PC 的低 28 位。<br>\nALU 的控制信号是 4 位，控制单元的输入是 func 字段和 2 位的 ALUop，op 决定操作是由 00 (加法)、01 (beq 的减法)、10（指令的 func 字段)（R 型指令的选择）来决定操作，输出的就是上面讲的 4 位控制信号。6 种组合看 p193。</p>\n<h4 id=\"七个1位控制信号\"><a class=\"markdownIt-Anchor\" href=\"#七个1位控制信号\">#</a> 七个 1 位控制信号</h4>\n<p>对着书上的图 p196 看看位置</p>\n<table>\n<thead>\n<tr>\n<th>信号名</th>\n<th>置无效时（0）效果</th>\n<th>置有效时（1）的效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RegDst</td>\n<td>写入寄存器时，目标寄存器编号来自 rt 字段</td>\n<td>写入寄存器时，目标寄存器编号是 rd 字段 (15:11)</td>\n</tr>\n<tr>\n<td>RegWrite</td>\n<td>无</td>\n<td>数据写入由写入寄存器输入端口指定的寄存器</td>\n</tr>\n<tr>\n<td>ALUSrc</td>\n<td>第二个 ALU 操作数来自寄存器堆第二个输出</td>\n<td>第二个 ALU 操作数是指令低 16 位的符号拓展</td>\n</tr>\n<tr>\n<td>PCSrc</td>\n<td>PC 使用 PC+4 更新</td>\n<td>PC 使用分支目标地址更新</td>\n</tr>\n<tr>\n<td>MemRead</td>\n<td>无</td>\n<td>输入地址对应的数据输出到读数据输出端口</td>\n</tr>\n<tr>\n<td>MemWrite</td>\n<td>无</td>\n<td>将写入数据输入端的数据写入地址输入端指定的存储单元</td>\n</tr>\n<tr>\n<td>MemtoReg</td>\n<td>写入寄存器数据来自于 ALU</td>\n<td>写入寄存器数据来自数据存储器</td>\n</tr>\n</tbody>\n</table>\n<p>控制信号的输入和输出看 p200-201</p>\n<h3 id=\"流水线\"><a class=\"markdownIt-Anchor\" href=\"#流水线\">#</a> 流水线</h3>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>指令执行时</mtext><msub><mtext>间</mtext><mtext>流水线</mtext></msub><mo>=</mo><mfrac><mrow><mtext>指令执行时</mtext><msub><mtext>间</mtext><mtext>非流水线</mtext></msub></mrow><mtext>流水线级数</mtext></mfrac></mrow><annotation encoding=\"application/x-tex\">指令执行时间_{流水线}=\\frac{指令执行时间_{非流水线}}{流水线级数}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord cjk_fallback\">指</span><span class=\"mord cjk_fallback\">令</span><span class=\"mord cjk_fallback\">执</span><span class=\"mord cjk_fallback\">行</span><span class=\"mord cjk_fallback\">时</span><span class=\"mord\"><span class=\"mord cjk_fallback\">间</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">流</span><span class=\"mord cjk_fallback mtight\">水</span><span class=\"mord cjk_fallback mtight\">线</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2336359999999997em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8886359999999999em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">流</span><span class=\"mord cjk_fallback mtight\">水</span><span class=\"mord cjk_fallback mtight\">线</span><span class=\"mord cjk_fallback mtight\">级</span><span class=\"mord cjk_fallback mtight\">数</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.410305em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">指</span><span class=\"mord cjk_fallback mtight\">令</span><span class=\"mord cjk_fallback mtight\">执</span><span class=\"mord cjk_fallback mtight\">行</span><span class=\"mord cjk_fallback mtight\">时</span><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">间</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.3567071428571427em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">非</span><span class=\"mord cjk_fallback mtight\">流</span><span class=\"mord cjk_fallback mtight\">水</span><span class=\"mord cjk_fallback mtight\">线</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.14329285714285717em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> 这个公式要在程序指令多时成立</p>\n<h3 id=\"面向流水线的设计\"><a class=\"markdownIt-Anchor\" href=\"#面向流水线的设计\">#</a> 面向流水线的设计</h3>\n<p>为什么 mips 适合流水线:</p>\n<ul>\n<li>所有指令长度相同</li>\n<li>指令格式少，并且每条指令寄存器字段位置相同 (对称性），确定取指类型同时开始读取寄存器堆</li>\n<li>存储器操作数仅出现在 load 和 store，不可以直接访问内存</li>\n<li>所有操作数都必须在存储器对齐</li>\n</ul>\n<h4 id=\"数据冒险\"><a class=\"markdownIt-Anchor\" href=\"#数据冒险\">#</a> 数据冒险</h4>\n<p>有三种冒险类型</p>\n<ol>\n<li>结构冒险：就是两条指令同时访问一个硬件</li>\n<li>数据冒险：取数指令取的数是之前的目标，通过增加硬件来提前得到缺少运算项，这个方法叫做前推 (forwarding) 或者叫做旁路 (bypassing)<br>\n 取数 - 使用型数据冒险 (load-use data hazard) 上一个指令 lw，下一个指令就用，这会导致<br>\n流水线阻塞（pipeline stall) 或叫做空泡 (bubble)</li>\n<li>控制冒险：决策依赖于一条指令的结果，而其他指令正在执行。就是要看第一条指令结果再决定是否进行下一步，其实就是 beq 是否跳转<br>\n解决方法是：阻塞（stall) 或者预测（predict)(通常预测分支不发生如果真发生的话会产生阻塞) 或延迟决定（就是用不相关的指令先搪塞着（调节指令顺序））</li>\n</ol>\n<blockquote>\n<p>阻塞对性能影响可以看 p210</p>\n</blockquote>\n<h4 id=\"流水线小结\"><a class=\"markdownIt-Anchor\" href=\"#流水线小结\">#</a> 流水线小结</h4>\n<p>流水线不能减少单条指令执行时间（也叫延迟（latency）），流水线指示提高了吞吐率（throughput)。</p>\n<h3 id=\"流水线数据通路与控制\"><a class=\"markdownIt-Anchor\" href=\"#流水线数据通路与控制\">#</a> 流水线数据通路与控制</h3>\n<p>数据通路有五个部分：</p>\n<ul>\n<li>IF：取指令</li>\n<li>ID：指令译码，读寄存器堆</li>\n<li>EX: 执行或计算地址</li>\n<li>MEM：访问数据存储器</li>\n<li>WB：写回<br>\n每两个阶段中间有一个流水线寄存器，IF/ID 这种，store 指令最后 WB 啥也不做，但是也没有优化空间。<br>\n每一个逻辑单元都只能在一个流水线中使用，否则会产生结构冒险，因此这些单元及其控制可以和一个流水级相关联<br>\n流水线可以看 p216-220<br>\n 多时钟周期图在 p223，不过不知道要不要画。。。，单时钟周期就是电路图上面加了个表，在 p224</li>\n</ul>\n<h4 id=\"流水线数据冒险旁路与阻塞\"><a class=\"markdownIt-Anchor\" href=\"#流水线数据冒险旁路与阻塞\">#</a> 流水线数据冒险：旁路与阻塞</h4>\n<p>sub 指令的结果被下一条指令用到，旁路条件:<br>\n1a. EX/MEM.RigisterRd=ID/EX.RegisterRs（Rd 不等于 0&amp;&amp;regwrite=1）<br>\n1b.EX/MEM.RigisterRd=ID/EX.RegisterRt<br>\n2a. MEM/WB.RigisterRd=ID/EX.RegisterRs<br>\n2b. MEM/WB.RigisterRd=ID/EX.RegisterRd<br>\n 这个表明流水线下 sub 这类指令会影响下面两条指令 1 和 2 的区别在于下一条还是下面第二条指令<br>\n为了这个旁路，我们亲爱的 ID/EX 流水线寄存器还多了个 5 位的 rs 字段，之前是直接保存 rs 的值的，现在 key 也要保存了。<br>\n这个具体操作还是得看 p231，信号看 p233</p>\n<table>\n<thead>\n<tr>\n<th>EX 冒险</th>\n<th>MEM 冒险</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1.a:forwardA=10</td>\n<td>2.a:ForwardA=01</td>\n</tr>\n<tr>\n<td>1.bfowardB=10</td>\n<td>2.b:ForwardB=01</td>\n</tr>\n</tbody>\n</table>\n<p>A 和 B 其实是第一（二）个 ALU 操作数来源于哪里的问题，00 代表来自寄存器堆。<br>\n如果出现 add s1，s1，1；add s1，s1，1；add s1，s1，1 时，从 MEM/WB 去取，详情看 P233，因为 MEM 级是最新的，EX/MEM 最新的还没写进去。<br>\n# 问了老师可能书上是错的，因为 EX 是最新的</p>\n<blockquote>\n<p>sw 和 lw 的冒险看 ppt，不过只能避免一次阻塞，也就是说有冲突必有一空泡</p>\n</blockquote>\n<h3 id=\"冒险与阻塞\"><a class=\"markdownIt-Anchor\" href=\"#冒险与阻塞\">#</a> 冒险与阻塞</h3>\n<p>load 指令必须阻塞一个时钟周期，这个检测叫冒险检测，检测如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(ID/EX.MemRead and ((ID/EX.Rt=IF/IF.Rs)or(ID/EX.Rt=IF/ID.Rt)))</span><br><span class=\"line\">stall the pipeline</span><br></pre></td></tr></table></figure>\n<p>人话就是如果读的话，然后 ID/EX 的存储寄存器等于下一指令的运算寄存器就停。<br>\n阻塞的办法就是保持 PC 和 IF/ID 流水线寄存器不变。<br>\nEX 开始的部分都是 nop，将 EX、MEM 和 WB 级的 9 个控制信号清除（置 0）。方法是将 ID/EX 流水线寄存器的这三个控制信号置为 0。<br>\n这导致这个指令 IF 级在第三个时钟周期，ID 级在第五个时钟周期</p>\n<h3 id=\"控制冒险或分支冒险\"><a class=\"markdownIt-Anchor\" href=\"#控制冒险或分支冒险\">#</a> 控制冒险或分支冒险</h3>\n<p>看 p238，</p>\n<h3 id=\"假定分支不发生\"><a class=\"markdownIt-Anchor\" href=\"#假定分支不发生\">#</a> 假定分支不发生</h3>\n<p>丢弃指令就是把控制信号置 0，要改变 IF、ID 和 EX 级的三条控制信号，而不是单单 ID 级的</p>\n<h3 id=\"缩短分支延迟\"><a class=\"markdownIt-Anchor\" href=\"#缩短分支延迟\">#</a> 缩短分支延迟</h3>\n<p>将分支执行到 ID 级，通过逻辑门的异或来判断。<br>\n为了在 IF 级清除指令，我们加入 IF.Flush 的控制信号，将 IF/ID 流水线寄存器的指令字段置为 0</p>\n<h3 id=\"动态分支预测dynamic-branch-prediction\"><a class=\"markdownIt-Anchor\" href=\"#动态分支预测dynamic-branch-prediction\">#</a> 动态分支预测 (dynamic branch prediction)</h3>\n<p>采用分支预测缓存 (cache) 或叫做分支历史记录表 (history table), 一位数据表示最近是否发生，但是一个总是发生分支第一次和最后一次会错误。<br>\n因而采用两位预测位，具体实现看 p241-242</p>\n<h2 id=\"异常\"><a class=\"markdownIt-Anchor\" href=\"#异常\">#</a> 异常</h2>\n<p>控制最难部分之一是实现异常和中断。很多操作系统不区分异常和中断，但 mips 中异常是任何意外的改变，无论内外，中断是由外部引起的事件。具体看 p245 的分类<br>\n I/O 设备请求错误就是中断，像算法溢出之类就是异常（不过感觉不是很清楚）</p>\n<p>异常发生时在 EPC (exception pc) 保存出错指令的地址，将控制权转交给操作系统的特定地址。两种方法表示异常原因，一个是 Cause 寄存器，一个是向量中断（vectored interrupt），在向量中断中，控制权转移到由异常原因决定的地址处。<br>\n多个异常在同一时钟周期同时发生先处理最早发生的异常，注意此处 EX 的异常与下一指令的 ID 异常为同一时钟周期，而不是 IF</p>\n<h2 id=\"指令级并行\"><a class=\"markdownIt-Anchor\" href=\"#指令级并行\">#</a> 指令级并行</h2>\n<h3 id=\"多发射multiple-issue\"><a class=\"markdownIt-Anchor\" href=\"#多发射multiple-issue\">#</a> 多发射（multiple issue）</h3>\n<p>每一阶段有多个状态单元和组合逻辑单元<br>\n分为静态多发射（static）：决策在编译阶段做出 和动态多发射：决策在执行阶段做出</p>\n<h4 id=\"推测speculation\"><a class=\"markdownIt-Anchor\" href=\"#推测speculation\">#</a> 推测（speculation）</h4>\n<p>交换指令顺序，可能会导致原本不异常的地方异常。</p>\n<h4 id=\"静态多发射处理器\"><a class=\"markdownIt-Anchor\" href=\"#静态多发射处理器\">#</a> 静态多发射处理器</h4>\n<p>使用编译器帮助打包多条指令并处理冒险。在给定时钟周期发射多条指令，也称为发射包（issue packet). 可将发社保看作允许同时执行多个操作的一条指令：超长指令字（Very Long Instruction Word，VLIW)<br>\n 一般是双发射。（两个指令一次打包。）组合逻辑单元基本都要加倍<br>\n详细过程看 p252<br>\n 这个编译器又能处理一个包的各种冒险 (不包括包与包之间的)，又要减少 load 的使用延迟对打包后的 ALU 的影响，真强大。<br>\n答题看 p253-254</p>\n<p>另一种更高性能编译技术是循环展开 (loop unrolling)<br>\n 此时需要寄存器重命名来消除一些虚假的数据相关，也叫反相关（antidependence)，或者名字相关</p>\n<h4 id=\"动态多发射处理器\"><a class=\"markdownIt-Anchor\" href=\"#动态多发射处理器\">#</a> 动态多发射处理器</h4>\n<p>也叫超标量处理器（superscalar)<br>\n 采用动态流水线调度 (dynamic pipeline scheduling)</p>\n<h2 id=\"能耗效率\"><a class=\"markdownIt-Anchor\" href=\"#能耗效率\">#</a> 能耗效率</h2>\n<p>每块芯片集成多个处理器，要比复杂处理器功耗要好。</p>\n<h1 id=\"存储器存储结构\"><a class=\"markdownIt-Anchor\" href=\"#存储器存储结构\">#</a> 存储器存储结构</h1>\n<p>局部性原理：</p>\n<ul>\n<li>时间局部性 (temporal locality): 某个数据时间上访问间隔短</li>\n<li>空间局部性（spatial locality）：空间上间距短<br>\n用局部性原理组织成存储器层次结构<br>\n高级存储器靠近处理器较贵。<br>\n我们将两级层次结构中存储信息的最小单元称为块（block) 或行（line）<br>\n如果高层存储器没有找到所需数据那么这次数据请求称为一次缺失。<br>\n命中率（hit rate）<br>\n缺失率（1 - 命中率）<br>\nhit time<br>\nmiss penalty<br>\ncache 由 SRAM (静态随机存取存储器) 实现<br>\n memory 由 DRAM 实现</li>\n</ul>\n<h3 id=\"sram\"><a class=\"markdownIt-Anchor\" href=\"#sram\">#</a> SRAM</h3>\n<p>空闲模式下需要最小功率保持电荷，不需要刷新，对任何数据的访问时间是固定的，供电状态下数值不变</p>\n<h3 id=\"dram\"><a class=\"markdownIt-Anchor\" href=\"#dram\">#</a> DRAM</h3>\n<p>使用电容保存电荷，因为电容保存，所以不能长久地保持数据，需要周期性地刷新，这也是动态的原因</p>\n<p>有 DDR（双数据速率）这个型号。这个是时钟上升下降沿都输入输出信息<br>\n DDR4 这种可对 4 个 bank 发送一个地址同时访问，用轮转方式对这四个 bank 访问可以提供四倍带宽，也称地址交叉<br>\n书上讲的不明所以，建议看 ppt</p>\n<h3 id=\"闪存\"><a class=\"markdownIt-Anchor\" href=\"#闪存\">#</a> 闪存</h3>\n<p>写操作会产生损耗，所以会有控制器将已经很多次地块重映射到写入次数较少的块中。俗称损耗均衡 (wear leveling) 技术</p>\n<h3 id=\"磁盘存储器\"><a class=\"markdownIt-Anchor\" href=\"#磁盘存储器\">#</a> 磁盘存储器</h3>\n<p>一个磁盘具有一组瓷盘片，绕轴每分钟转动近 10000 圈。每层表面有一个包含小型电磁线圈的读写磁头。</p>\n<p>每个磁盘表面划分为同心圆盘，称为磁道，每个磁道被划分为存储信息的扇区。扇区容量 0.5KiB~4Kib.<br>\n 访问数据三步骤：</p>\n<ul>\n<li>寻道。找到适当磁道</li>\n<li>等待要访问扇区转动到读写头下面，等待时间称为旋转延迟</li>\n<li>传输时间<br>\n传输时间计算得看 ppt</li>\n</ul>\n<h2 id=\"cache基本原理\"><a class=\"markdownIt-Anchor\" href=\"#cache基本原理\">#</a> cache 基本原理</h2>\n<p>cache 大小不含标记位和有效位，具体算大小位数看 p292. 标记字段大小是 32-n（块的个数）-m（一块中字的个数）-2（默认字的字节偏移量）<br>\ncache 的有效大小位数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>∗</mo><msup><mn>2</mn><mi>m</mi></msup><mo>∗</mo><mn>32</mn></mrow><annotation encoding=\"application/x-tex\">2^{n}*2^{m}*32</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">2</span></span></span></span><br>\n 总位数等于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>∗</mo><mo stretchy=\"false\">(</mo><mtext>块大小</mtext><mo>+</mo><mtext>标记字段大小</mtext><mo>+</mo><mtext>有效位字段大小</mtext><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">2^{n}*(块大小+标记字段大小+有效位字段大小)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord cjk_fallback\">块</span><span class=\"mord cjk_fallback\">大</span><span class=\"mord cjk_fallback\">小</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord cjk_fallback\">标</span><span class=\"mord cjk_fallback\">记</span><span class=\"mord cjk_fallback\">字</span><span class=\"mord cjk_fallback\">段</span><span class=\"mord cjk_fallback\">大</span><span class=\"mord cjk_fallback\">小</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord cjk_fallback\">有</span><span class=\"mord cjk_fallback\">效</span><span class=\"mord cjk_fallback\">位</span><span class=\"mord cjk_fallback\">字</span><span class=\"mord cjk_fallback\">段</span><span class=\"mord cjk_fallback\">大</span><span class=\"mord cjk_fallback\">小</span><span class=\"mclose\">)</span></span></span></span> 别忘了这个有效位 1 位<br>\n地址映射看 p293，是向下取整。</p>\n<p>如果仅仅增加块大小，会导致 miss penalty 的增加。<br>\n解决方法就是加快传输速率，减少这个延迟可以隐藏一些传输时间，最简单方法就是提前重启（early restart），即块中所需的字一旦返回就马上继续执行。不过这个问题在于字的分布不确定，同时若下一条指令请求另一块中的字，那么处理器就无法访问 cache。还有一种方法是关键字有限，在 p295；</p>\n<h4 id=\"cache缺失处理cache-miss\"><a class=\"markdownIt-Anchor\" href=\"#cache缺失处理cache-miss\">#</a> cache 缺失处理（cache miss）</h4>\n<p>cache 缺失处理由两部分共同完成：处理器控制单元，以及一个进行初始化主存访问和重新填充 cache 的独立控制器。cache 缺失引起流水线阻塞，阻塞整个处理器，冻结所有内容。我们假定顺序执行处理器。</p>\n<blockquote>\n<p>乱序执行（out-of-order) 处理器在等待缺失处理同时仍能执行部分指令</p>\n</blockquote>\n<p>指令 cache 缺失处理步骤：</p>\n<ol>\n<li>PC 原始值 (PC-4) 送到存储器中</li>\n<li>通知主存执行一次读操作，并等待主存访问完成</li>\n<li>写 cache 项，将从主存读回数据写入 cache 存放数据的部分。并将地址高位写入标记字段，设置有效位。</li>\n<li>重启执行执行第一步，重新取指，这次该指令在 cache 中.<br>\n 数据缺失同理。</li>\n</ol>\n<h4 id=\"写操作处理\"><a class=\"markdownIt-Anchor\" href=\"#写操作处理\">#</a> 写操作处理</h4>\n<p>为保持 cache 和 memory 的一致性，我们采用两种办法:</p>\n<ul>\n<li>write-through（写直达）直接将更改的字写入 cache 和 memory 中\n<ul>\n<li>可以使用 (write buffer), 如果存储器完成写操作速度慢于产生写操作速度，那么没有作用。</li>\n</ul>\n</li>\n<li>write-back (写回)，被替换时才要写道较低层存储结构。下面各种时 cache 缺失策略</li>\n<li>写分配，在 cache 中分配一块</li>\n<li>写不分配，只更新主存，不写入 cache 中。<br>\n写直达比写回安全，因为写直达有内存备份，而写回没有，所以写回必须得判断 cache 是否命中再完成写操作，而写直达不需要，因为缺失就再次更改 cache。</li>\n</ul>\n<h3 id=\"小结\"><a class=\"markdownIt-Anchor\" href=\"#小结\">#</a> 小结</h3>\n<p>cache 性能可通过增加主存带宽：增加存储器位宽和交叉存取。<br>\n计算性能看 p301<br>\n 平均存储器访问时间 (Average Memory Access Time,AMAT)：<br>\nAMAT = 命中时间 + 缺失率 <code>*</code>  缺失代价</p>\n<h3 id=\"灵活放置块\"><a class=\"markdownIt-Anchor\" href=\"#灵活放置块\">#</a> 灵活放置块</h3>\n<p>全相联：块可以放在 cache 任何位置，适用块数较少的 cache<br>\n 组相联：介于直接映射和全相联之间。每个块有 n 个可放位置叫做 n 路组相联 cache。（n 也称为相联度）<br>\n降低缺失率但是增加了命中时间。<br>\n采用更换最少被访问的块的规则更新组。<br>\n相同容量和相同块大小下，相联度其实也就一路到二路好点，缺失率降低了 15%，其余基本改善空间不大。</p>\n<h4 id=\"在组相联中找cache块\"><a class=\"markdownIt-Anchor\" href=\"#在组相联中找cache块\">#</a> 在组相联中找 cache 块</h4>\n<table>\n<thead>\n<tr>\n<th>标记</th>\n<th>索引</th>\n<th>块偏移</th>\n</tr>\n</thead>\n</table>\n<p>这个是查找的信息。每组采用并行检索标记号。需要 n 个比较器和一个 n 选 1 的多路选择器。</p>\n<h4 id=\"替换块\"><a class=\"markdownIt-Anchor\" href=\"#替换块\">#</a> 替换块</h4>\n<p>采用 LRU（Least recently used）法，最久没有被使用的块。<br>\n组相联 n 越大，标记字段大小越大，因为索引其实不占 cache 大小。</p>\n<h4 id=\"使用多级cache减少损失代价\"><a class=\"markdownIt-Anchor\" href=\"#使用多级cache减少损失代价\">#</a> 使用多级 cache 减少损失代价</h4>\n<p>采用 L1 和 L2cache，多级 cache 性能看 p307<br>\n 主存缺失代价为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mn>100</mn><mi>n</mi><mi>s</mi></mrow><mrow><mn>0.25</mn><mfrac><mrow><mi>n</mi><mi>s</mi></mrow><mtext>时钟周期</mtext></mfrac></mrow></mfrac><mo>=</mo><mn>400</mn><mtext>个时钟周期</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{100ns}{0.25\\frac{ns}{时钟周期}}=400个时钟周期</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.4309079999999998em;vertical-align:-0.5857999999999999em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.845108em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">0</span><span class=\"mord mtight\">.</span><span class=\"mord mtight\">2</span><span class=\"mord mtight\">5</span><span class=\"mord mtight\"><span class=\"mopen nulldelimiter sizing reset-size3 size6\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6915428571428572em;\"><span style=\"top:-2.656em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">时</span><span class=\"mord cjk_fallback mtight\">钟</span><span class=\"mord cjk_fallback mtight\">周</span><span class=\"mord cjk_fallback mtight\">期</span></span></span></span><span style=\"top:-3.2255000000000003em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line mtight\" style=\"border-bottom-width:0.049em;\"></span></span><span style=\"top:-3.384em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">s</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.344em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter sizing reset-size3 size6\"></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span><span class=\"mord mtight\">0</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">s</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5857999999999999em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">4</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord cjk_fallback\">个</span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">钟</span><span class=\"mord cjk_fallback\">周</span><span class=\"mord cjk_fallback\">期</span></span></span></span> 这种形式<br>\n L1cache 致力于减少命中时间，L2cache 致力于改善缺失率<br>\n快排比基数排序要快因为 cache 缺失率低。</p>\n<p>L2cache 的局部缺失率挺高的，但是全局缺失率低。</p>\n<h2 id=\"可信性问题\"><a class=\"markdownIt-Anchor\" href=\"#可信性问题\">#</a> 可信性问题</h2>\n<p>冗余技术。<br>\n失效定义：两种状态：</p>\n<ul>\n<li>服务完成：交付的服务于需求不符。</li>\n<li>服务中断：交付的服务与需求不符。<br>\n失效导致状态 1 到状态 2 的转换。状态 2 到状态 1 称为恢复。<br>\n平均无故障时间（Mean Time To Failure，MTTF）是一个可靠性度量方法。年失效率（Annual Failure Rate，AFR）指在给定 MTTF 下，一年内预期的器件失效比例。<br>\n服务中断用平均修复时间（Mean Time To Repair，MTTR) 来度量。平均失效间隔（Mean time Between Failure，MTBF）=MTTF+MTTR。<br>\n可用性指系统正常工作时间连续两次服务中断间隔时间中所占的比例：<br>\n可用性 =<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>M</mi><mi>T</mi><mi>T</mi><mi>F</mi></mrow><mrow><mi>M</mi><mi>T</mi><mi>T</mi><mi>F</mi><mo>+</mo><mi>M</mi><mi>T</mi><mi>T</mi><mi>R</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{MTTF}{MTTF+MTTR}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.275662em;vertical-align:-0.403331em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.872331em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.403331em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span><br>\n 用术语故障（fault）来表示一个器件的失效，用三种方式可以提高系统的 MTTF：</li>\n<li>故障避免技术：合理构建系统</li>\n<li>故障容忍技术：荣誉措施</li>\n<li>故障预测技术：在器件失效前进行替换</li>\n</ul>\n<h2 id=\"纠正一位错-检测两位错的汉明编码secded\"><a class=\"markdownIt-Anchor\" href=\"#纠正一位错-检测两位错的汉明编码secded\">#</a> 纠正一位错、检测两位错的汉明编码（SEC/DED)</h2>\n<p>parity 校验码检测 1 位错误，称为 1 位错误检测编码（1 表示奇数，0 表示偶数）。汉明纠错码（Hamming Error Correcting Code，ECC）。<br>\n我们采用额外的校验位确定单个错误的位置。具体看 p315<br>\n 校验位 1、2、4、8（编号二进制第 logn+1 位为 1）。此外，我们可以通过增加 1 位来导致码字中的最小汉明距离变到 4。可以纠正 1 位错检测 2 位错。这个增加的校验位取决于前面的奇偶纠错校验位和原数据位的奇偶产生的偶校验<br>\n以下是出现的四种情况（H 位纠错码组的奇偶性，全局奇偶校验位为 p）：</p>\n<ol>\n<li>H 为偶，p 为偶，无错误发生</li>\n<li>H 为奇，P 为奇，出现一个可纠正错误。</li>\n<li>H 为偶，P 为奇，p 错了</li>\n<li>H 为奇，p 为偶，常出现两位错<br>\n纠错位<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>p</mi></msup><mo>&gt;</mo><mo>=</mo><mi>p</mi><mo>+</mo><mi>d</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^{p}&gt;=p+d+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.703492em;vertical-align:-0.0391em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7777700000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></li>\n</ol>\n<h2 id=\"虚拟机\"><a class=\"markdownIt-Anchor\" href=\"#虚拟机\">#</a> 虚拟机</h2>\n<p>操作系统虚拟机能与硬件匹配。<br>\n支持虚拟机的软件称为虚拟机监视器 (Virtual Machine Monitor,VMM) 或者管理程序 (hypervisor):VMM 是虚拟机技术核心。底层硬件平台叫主机（host），其资源被客户端（guest）虚拟机共享。<br>\n虚拟机保护功能不错，同时，商业意义上，它也有其他两个重要优势：</p>\n<ul>\n<li>软件管理：提供一个可以运行完整软件栈的抽象</li>\n<li>硬件管理：允许独立软件栈在共享硬件的同时独立运行，合并了服务器的数量。<br>\n每个客户端只能达到用户级，VMM 能达到更高级，从而保证特权指令执行</li>\n</ul>\n<h3 id=\"虚拟存储器virtual-memory\"><a class=\"markdownIt-Anchor\" href=\"#虚拟存储器virtual-memory\">#</a> 虚拟存储器（virtual memory）</h3>\n<p>虚拟存储器中，块称为页，访问缺失叫做缺页。虚拟地址，由软件和硬件结合转化为物理地址。<br>\n在虚拟存储器中，地址被划分为虚拟页号（virtual page number）和页偏移（page offset），页偏移与物理地址一致，在低位。缺页改进方法看 p321</p>\n<h3 id=\"页的存放和查找\"><a class=\"markdownIt-Anchor\" href=\"#页的存放和查找\">#</a> 页的存放和查找</h3>\n<p>页表（page table），存放在主存中，用虚拟地址中的页号作为索引，这个页表位置由页表寄存器给出。每个虚拟机由一块页表</p>\n<p>页表每一 entry 都有一个有效位。由于页表表示了所有虚拟页映射，所以不用标志位。看 p324 这张图。</p>\n<p>如果虚拟也有效位无效，会出现缺页故障，那么内存要去硬盘找到该页。这个交换空间是在进程开始时在闪存或磁盘上创建的交换区 (swap space), 不管存在主存还是磁盘上，页大小相等。</p>\n<p>LRU 替换策略</p>\n<p>写回机制，替换时写回磁盘。页表中加个脏页。</p>\n<h3 id=\"加快地址转换tlb\"><a class=\"markdownIt-Anchor\" href=\"#加快地址转换tlb\">#</a> 加快地址转换：TLB</h3>\n<p>cache 快表 (Translation-Lookaside Buffer,TLB),TLB 中由脏位和引用位等状态位。每次访问先在 TLB 查找虚拟页号。命中的话物理页号形成地址，引用位被置位，写操作还是设置脏位。TLB 缺失要判断时页缺失还是 TLB 缺失。引用位其实就是用来 LRU 的。<br>\nTLB 换项时将引用位和脏位换到页表里（写回操作在 TLB 缺失时再写，会很高效）<br>\nTLB 采用全相联，同时随机选择替换表项。<br>\n看 p330 和 ppt<br>\n 还有 p331</p>\n<p>虚拟地址索引 cache 块，标记 TLB，可以直接知道 cache 块中有没有所需内容。</p>\n<p>TLB 的写访问位能让一个恶意进程不能写另一个用户进程的地址空间，写访问位由 VMM 控制。<br>\n进程切换时，TLB 一定要切换成另一个表的表项。或者用进程标识符和任务标识符</p>\n<h3 id=\"处理tlb缺失和缺页\"><a class=\"markdownIt-Anchor\" href=\"#处理tlb缺失和缺页\">#</a> 处理 TLB 缺失和缺页</h3>\n<ul>\n<li>页在主存，创建表项</li>\n<li>不在主存，控制权交给操作系统处理缺页<br>\n出现 TLB 缺失和缺页要使用异常机制，EPC 记录程序计数器的值<br>\n异常必须在同一时钟周期的末尾被判定。<br>\n使主存写控制线无效。<br>\n异常处理时禁止其他异常。<br>\n页缺失时被引用的页号被保存在 BADVaddr 的特殊寄存器里。<br>\nTLB 缺失表项插入过程看 p336，有点麻烦  处理时并不会检查表项是否有效，直接会插入。</li>\n</ul>\n<h3 id=\"小结-2\"><a class=\"markdownIt-Anchor\" href=\"#小结-2\">#</a> 小结</h3>\n<p>虚拟存储器允许单个程序地址空间拓展到主存界限之外。增大 memory 的表面大小（apparent size)<br>\n 采用技术降低缺失率：</p>\n<ul>\n<li>增大页容量</li>\n<li>全相联</li>\n<li>LRU 和访问位之类技术决定选择替换哪一页</li>\n</ul>\n<h3 id=\"存储器框架\"><a class=\"markdownIt-Anchor\" href=\"#存储器框架\">#</a> 存储器框架</h3>\n<p>cache 容量增加，相连度提高对性能改进作用很小，其余看 p339 吧，感觉没啥。<br>\n页表采用的是全相联全映射<br>\n cache 替换策略：相联度较高的采用随机法，较低的采用 LRU（近似实现）<br>\n写直达比写回好实现。缺失代价小：不用把整块写回更低级存储系统</p>\n<h3 id=\"3c模型\"><a class=\"markdownIt-Anchor\" href=\"#3c模型\">#</a> 3C 模型</h3>\n<ul>\n<li>强制缺失（compulsory miss）也称冷启动 (cold-start miss)：<br>\n从未出现过的块的第一次访问缺失</li>\n<li>容量缺失 (capacity miss) ：cache 某个块被替换后再次访问的缺失</li>\n<li>冲突缺失（conflict miss）也称碰撞缺失 (collision miss)：<br>\n多个块竞争同一组，全相联不存在这个问题。<br>\n强制缺失可以增大块来解决<br>\n容量缺失增大容量<br>\n看 p343 的表</li>\n</ul>\n<h3 id=\"有限状态机控制简单的cache\"><a class=\"markdownIt-Anchor\" href=\"#有限状态机控制简单的cache\">#</a> 有限状态机控制简单的 cache</h3>\n<p>有限状态机通常假定那些没有明确置为有效的信号设置为无效信号。有限状态机实现看 p345，由一个组合逻辑和一个保持当前状态的寄存器实现。称为阻塞性（blocking）cache。</p>\n<h3 id=\"一个简单cache控制器的有限状态机\"><a class=\"markdownIt-Anchor\" href=\"#一个简单cache控制器的有限状态机\">#</a> 一个简单 cache 控制器的有限状态机</h3>\n<p>cache 控制器的 4 个状态:</p>\n<ul>\n<li>空闲：</li>\n<li>标记比较：</li>\n<li>写回：将 128 位的块写回存储器（DRAM 控制器通常是 128 位）</li>\n<li>分配：<br>\n懒得写了看 p346 吧，都要等待准备好信号。标记比较状态可以和 cache 访问分离，以及价格写缓冲可以改进时钟周期</li>\n</ul>\n<h3 id=\"cache一致性\"><a class=\"markdownIt-Anchor\" href=\"#cache一致性\">#</a> cache 一致性</h3>\n<p>多核多处理器，多个处理器共享一个公共的物理地址空间。但是 cache 各自拥有<br>\n一致性和连贯性：</p>\n<ul>\n<li>单个 CPU 写后读的就是写过的</li>\n<li>一个写操作后其他 CPU 在一定间隔后可以得到写过的</li>\n<li>写操作是串行执行的，不会出现同时写入<br>\n实现一致性的基本方案：</li>\n<li>迁移（migration）：数据项移入本地 cache，这样可以不用访问共享寄存器</li>\n<li>复制（replication）：共享数据被同时读取时，cache 在本地对数据项做备份，减少读取竞争<br>\n cache 一致性协议：最常用的是监听 (snooping) 协议。cache 保留数据块共享状态的副本，不集中保存状态。所有 cache 控制器对广播介质（总线或者网络）进行监视或者监听，来确保是否由总线或交换机上的数据块副本。</li>\n</ul>\n<h4 id=\"监听协议\"><a class=\"markdownIt-Anchor\" href=\"#监听协议\">#</a> 监听协议</h4>\n<p>写无效协议 (write invalidate protocol) 处理器写操作前令其他副本无效。此时其他处理器读时需要重新请求新的数据副本，这时仍有效的 CPU 数据副本就会响应。<br>\n不过写操作处理器要独占访问，采用 random rule。</p>\n<h2 id=\"io\"><a class=\"markdownIt-Anchor\" href=\"#io\">#</a> I/O</h2>\n<p>打印机采用轮询（polling）方式，其他基本采用中断，较慢的情况下</p>\n",
            "tags": [
                "笔者是菜鸟，上课不记笔记，因而只有补天笔记了"
            ]
        }
    ]
}