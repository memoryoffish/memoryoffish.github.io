{
    "version": "https://jsonfeed.org/version/1",
    "title": "Blog",
    "subtitle": "",
    "icon": "https://memoryoffish.github.io/images/favicon.ico",
    "description": "",
    "home_page_url": "https://memoryoffish.github.io",
    "items": [
        {
            "id": "https://memoryoffish.github.io/2025/01/25/less/x86/mips/",
            "url": "https://memoryoffish.github.io/2025/01/25/less/x86/mips/",
            "title": "x86汇编笔记",
            "date_published": "2025-01-25T09:15:00.000Z",
            "content_html": "<h1 id=\"期末复习\"><a class=\"anchor\" href=\"#期末复习\">#</a> 期末复习</h1>\n<ol>\n<li>dos 程序里有 edit main.asm 这条 edit 指令按 F3 和 E 退出</li>\n</ol>\n<h2 id=\"数制\"><a class=\"anchor\" href=\"#数制\">#</a> 数制</h2>\n<p>十六进制 h 或 H 为后缀 最高位是字母要加前缀 0<br />\n 八进制 Q 或 q 为后缀<br />\n二进制 B 或 b 为后缀</p>\n<h3 id=\"数的位\"><a class=\"anchor\" href=\"#数的位\">#</a> 数的位</h3>\n<p>bit (1 位)、byte（8 位）、word（16 位）、dword（32 位）、qword（64 位）、tbyte（80 位）共 6 种<br />\n采用小数排序，低位在后，高位在前对应的有高字节低字节高字低字的说法，在 data 段表示如下：<br />\ndw：word 相当于 short int 或 unsigned short int<br />\ndd：dword 相当于 long int 或 unsigned long int 或 float 类型<br />\n db: byte<br />\ndq：qword 相当于 long long 或 double<br />\ndt：tbyte long double<br />\n 这些都可以表示数组，关键看后面数量<br />\n注意 <code>a db &quot;abc&quot;</code>  是 'a','b','c' 要后面自己补 '\\0'</p>\n<h3 id=\"符号数\"><a class=\"anchor\" href=\"#符号数\">#</a> 符号数</h3>\n<p>首位为负的其他为正的</p>\n<h3 id=\"零扩充与符号扩充\"><a class=\"anchor\" href=\"#零扩充与符号扩充\">#</a> 零扩充与符号扩充</h3>\n<p>mov，add 这些要求两个操作数等宽，零扩充指非符号数扩 0，有符号数阔符号位陈伟符号扩充</p>\n<h3 id=\"字符表示\"><a class=\"anchor\" href=\"#字符表示\">#</a> 字符表示</h3>\n<p>ASCII 定义 256 个字符，标准 ASCII 仅需要后七位，128 个字符。0 到 1Fh 以及 7Fh 等 33 个不可打印<br />\n大小写字母距离 20h，也就是十进制的 32</p>\n<h3 id=\"二进制数据计算\"><a class=\"anchor\" href=\"#二进制数据计算\">#</a> 二进制数据计算</h3>\n<p>mul 是非符号乘法<br />\n imul 是符号数<br />\n fadd 是小数加法 <code>fadd st(0),st(1)</code> <br />\n 其他类推</p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>含义</th>\n<th>用法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>shl</td>\n<td>逻辑左移（shift logic left）</td>\n<td>shl ax,1 或 shl ax,cl (8086 中) 开头有.386 则可以把 1 改成任意 8 位常数        其实就是 dest&lt;&lt;=count &amp;1Fh 这个 1Fh 是 31 的意思，可以操作 c 这种数据变量</td>\n</tr>\n<tr>\n<td>shr</td>\n<td>逻辑右移</td>\n<td>最高位补 0，末尾进 CF</td>\n</tr>\n<tr>\n<td>sar</td>\n<td>算术右移</td>\n<td>首位不变，然后首位放入第二位，之后往后退，末位进 CF</td>\n</tr>\n<tr>\n<td>sal</td>\n<td>算术左移</td>\n<td>与逻辑左移是一样的，</td>\n</tr>\n<tr>\n<td>rol</td>\n<td>循环左移</td>\n<td>首位进入 CF，首位变成最后一位，依次往前</td>\n</tr>\n<tr>\n<td>rcl</td>\n<td>带进位循环左移</td>\n<td>首位进入 CF，CF 成为最后一位</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"cpu-内存和端口\"><a class=\"anchor\" href=\"#cpu-内存和端口\">#</a> CPU、内存和端口</h2>\n<p>由三部分组成：算术逻辑单元 (ALU)、控制单元（CU)、寄存器 (register)。CU 作用为取指令、解释指令、执行指令，只有寄存器可以编程控制<br />\n内存存储指令和变量执行 link 时，dos 会打开并读取 link.exe 载入内存，然后 link 在内存中运行。</p>\n<h3 id=\"内存\"><a class=\"anchor\" href=\"#内存\">#</a> 内存</h3>\n<p>dos 系统运行在 CPU 的实模式（real mode）下，可访问地址 <code>[00000h,0FFFFFh]</code>  这个 1MB 内存空间。<br />\n我们使用段地址：偏移地址这种组合形式来简介访问物理地址。<br />\n偏移地址表示某个变量或标号与段首距离，段地址是段首地址的高 16 位。<br />\n段是符合以下两要求的内存：</p>\n<ul>\n<li>长度为 10000h 即 64KB</li>\n<li>内存块 20 位首地址必须为 0<br />\n <code>[12340h,223Fh]</code>  可构成一个段，计算大小头尾都要计算<br />\n 12341h 可表示为 1234h:0001h</li>\n</ul>\n<h3 id=\"逻辑地址\"><a class=\"anchor\" href=\"#逻辑地址\">#</a> 逻辑地址</h3>\n<p>8086 中，逻辑地址就是上述写法，可以用 ds: <code>[5678h]</code>  的写法但是段地址不能用常数<br />\n在源程序中，用 offset 变量名或标号名来引用变量或标号的偏移地址如 <code>offset a</code> <br />\n, 段地址则用 seg a 或 seg s 或者段名 data 来引用 data 段的段地址。</p>\n<h4 id=\"直接寻址和间接寻址\"><a class=\"anchor\" href=\"#直接寻址和间接寻址\">#</a> 直接寻址和间接寻址</h4>\n<p>用常数表示偏移地址时为直接寻址，包含寄存器位间接寻址，如 <code>mov ax,ds:[bx+2]</code> <br />\n 直接寻址一般为段寄存器:var <code>[常数]</code>  或段寄存器: <code>[常数+var]</code>  因为这个变量其实编译后就变成了对应偏移地址常量了<br />\n间接寻址有四种：</p>\n<ul>\n<li><code>[寄存器]</code> : <code>[bp]、[bx]、[si]、[di]</code></li>\n<li><code>[寄存器+常数]</code></li>\n<li><code>[寄存器+寄存器]</code></li>\n<li><code>[寄存器+寄存器+常数]</code> <br />\n 注意到其实寄存器只能用 bp 和 bx 和 si 和 di 这四种 bx 其实就是个乱入的，后续发现只有三个塞进来的，<br />\n<strong>当然重要是当两个寄存器相加时，其中一个必须从 bp、bx 中选，另一个从 si、di 中选__这个常数可以是 0</strong>，然后其实加入变量也是可以的，因为变量其实就是常数如 var <code>[bx]</code> <br />\n 80836 的间接寻址比较普遍点，一般形式为 <code>[寄存器+寄存器*N+常数]</code> , 其中 N 是集合 {1,2,4,8} 内的一个元素，寄存器从以下寻找：<br />\nEAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI, 其实就是 bx 带家人来了，然后多了个 ESP</li>\n</ul>\n<h3 id=\"小端规则\"><a class=\"anchor\" href=\"#小端规则\">#</a> 小端规则</h3>\n<p>CPU 会先将低 8 位写在前高 8 位写在后<br />\n框架如下，存储 1234h</p>\n<p>| 地址 | 值  |<br />\n|---|---|<br />\n|2000 |34h |<br />\n|2001 |12h  |</p>\n<h3 id=\"缺省段址和段覆盖\"><a class=\"anchor\" href=\"#缺省段址和段覆盖\">#</a> 缺省段址和段覆盖</h3>\n<h4 id=\"缺省段址\"><a class=\"anchor\" href=\"#缺省段址\">#</a> 缺省段址</h4>\n<p>省略段地址规则如下:</p>\n<ul>\n<li>直接寻址为 DS</li>\n<li>间接寻址包含 BP 的话，就是 SS （栈嘛)</li>\n<li>间接寻址不含 BP，就是 DS</li>\n</ul>\n<h4 id=\"段覆盖\"><a class=\"anchor\" href=\"#段覆盖\">#</a> 段覆盖</h4>\n<p>其实就是加了段前缀 ss，cs，es，ds 这四个就是所有段寄存器</p>\n<p>小小总结下：就是四个段寄存器和四个偏移地址寄存器的故事</p>\n<h3 id=\"1m内存空间划分和显卡映射\"><a class=\"anchor\" href=\"#1m内存空间划分和显卡映射\">#</a> 1M 内存空间划分和显卡映射</h3>\n<p>16 位 CPU 只能访问 0000:0000 到 F000:FFFF 的 1M 内存空间，内存空间划分如下:<br />\n# 难记得很</p>\n<table>\n<thead>\n<tr>\n<th>地址范围</th>\n<th>用途</th>\n<th>大小</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>[0000:0000,9000:FFFF]</code></td>\n<td>操作系统和用户程序</td>\n<td>A0000h 嘛</td>\n</tr>\n<tr>\n<td><code>[A000:0000,A000:FFFF]</code></td>\n<td>映射显卡内存</td>\n<td>10000h</td>\n</tr>\n<tr>\n<td><code>[B000:0000,B000:7FFF]</code></td>\n<td>映射显卡内存</td>\n<td>8000h</td>\n</tr>\n<tr>\n<td><code>[B800:0000,B800:7FFF]</code></td>\n<td>映射显卡内存</td>\n<td>8000h</td>\n</tr>\n<tr>\n<td><code>[C000:0000,F000:FFFF]</code></td>\n<td>映射 ROM</td>\n<td>40000h</td>\n</tr>\n</tbody>\n</table>\n<p>口诀就是操作系统和字母开头不对付，三英战吕布，刘备一抵二</p>\n<h4 id=\"显卡映射\"><a class=\"anchor\" href=\"#显卡映射\">#</a> 显卡映射</h4>\n<h5 id=\"1文本映射\"><a class=\"anchor\" href=\"#1文本映射\">#</a> 1. 文本映射</h5>\n<p>80 <code>*</code> 25 的文本模式，左上角为 0 点，每两个内存单元为一个字符，第一个字节写入 ASCII 码值，第二个写入前景色和后景色，具体颜色看 30 页吧。高四位背景色，低四位前景色，可以思考先背景后前景。<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\tmov ax,0B800h</span><br><span class=\"line\">\tmov es,axx</span><br><span class=\"line\">\tmov di,0</span><br><span class=\"line\">\tmov al,&#x27;A&#x27;</span><br><span class=\"line\">\tmov ah,71h</span><br><span class=\"line\">\tmov cx,2000</span><br><span class=\"line\">again:</span><br><span class=\"line\">\tmov es:[di],ax;</span><br><span class=\"line\">\tadd di,2;</span><br><span class=\"line\">\tsub cx,1;</span><br><span class=\"line\">\tjnz again</span><br><span class=\"line\">\tmov ah,1</span><br><span class=\"line\">\tint 21h</span><br><span class=\"line\">\tmov ah,4Ch</span><br><span class=\"line\">\tint 21h</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2图形映射\"><a class=\"anchor\" href=\"#2图形映射\">#</a> 2. 图形映射</h5>\n<p>书上说的是 ax 是 0013h，int 10h 开启的 320 <code>*200</code>  同样左上角开始，每个内存单元为一个字符，一个内存单元用 256 种变化的颜色<br />\n <code>mov ax,0A00h</code> <br />\nmov es,ax<br />\nmov ax,0013h<br />\nint 10h<br />\n 恢复文本模式用 mov ax,0003h<br />\nint 10h</p>\n<h3 id=\"宽度修饰\"><a class=\"anchor\" href=\"#宽度修饰\">#</a> 宽度修饰</h3>\n<p>其实就是指针，有:</p>\n<ul>\n<li>byte ptr</li>\n<li>word ptr</li>\n<li>dword ptr<br />\n 这些都是用来修饰变量的<br />\n以下两种情况不用加宽度修饰:</li>\n<li>指令中的变量有变量名不需要加宽度修饰</li>\n<li>指令中的另一个操作数有明确宽度<br />\n就是事先用 db 什么的定义过了<br />\n inc dword ptr ds: <code>[si]</code></li>\n</ul>\n<h3 id=\"变量引用\"><a class=\"anchor\" href=\"#变量引用\">#</a> 变量引用</h3>\n<p>其实就是没有 iterator，导致数组每个不同步长要自己计算 就是 dword 要用 + 4 来走</p>\n<h3 id=\"寄存器\"><a class=\"anchor\" href=\"#寄存器\">#</a> 寄存器</h3>\n<p>8086 有 14 个寄存器:ax,bx,cx,dx,sp,bp,si,di,cs,ds,es,ss,ip,fl, 均为 16 位<br />\n 80836 除了段寄存器 cs，ds,es,ss 其他都加前缀 e 升级为 32 位<br />\n fl 是标志寄存器，IP,SP 也可以用来偏移地址，不过你用不了就是了<br />\n<strong> CS 不能用 mov 指令赋值，只能用 jmp far ptr、jmp dword ptr、call far<br />\nptr 这类间接改变，ds、es、ss 可以用 mov 赋值，但源操作数只能是寄存器或变量，注意有变量，同时寄存器只能是 x 四大傻和 sp、bp、si、di</strong><br />\ndos 在把控制权交给 exe 前，会对以下寄存器赋值:<br />\ncs = 代码段的段地址<br />\n IP = 首条指令偏移地址<br />\n SS = 堆栈段的段地址<br />\n SP = 堆栈段的长度<br />\n DS=PSP 段址<br />\n ES=PSP 段址<br />\n SS:SP 指向堆栈顶，PSP 是程序段前缀，是 dos 分配给 EXE，位于首段前的 100h 字节的内存块，存储了某些命令行参数，DS 不是数据段段地址，因而开始运行得先用 ax 赋值<br />\n #可能没看<br />\n实际能放在【】就那四个，sp 和 ip 动不了</p>\n<h3 id=\"标志寄存器\"><a class=\"anchor\" href=\"#标志寄存器\">#</a> 标志寄存器</h3>\n<p>FL 是标志寄存器，状态标志有六个：<br />\nCF,ZF,SF,OF,PF,AF<br />\n 控制标志有三个：<br />\nDF,IF,TF<br />\n 还剩下七位是保留位，除第一位为 1，其他保留位都为 0</p>\n<ul>\n<li>CF 受 add,sub,mul,imul 和移位影响，进位和借位 CF 置 1，与此有关指令 jc，jnc,clc (将 cf 清零 clear carry),stc (set carry),cmc (compelment 反转 carry) adc 带进位加就是结果多加个 CF</li>\n<li>ZF 受算术逻辑和移位影响，结果为 0 时，ZF=0，与其有关的指令为 jz 和 je 和 jnz 和 jne（等价）</li>\n<li>SF 取运算结果最高位，也就是结果为负之类的，有关的时 js 和 jns</li>\n<li>OF 为溢出标志，正数相加为负数负数相加为正数还有乘积大于被乘数宽度这类的 OF=1，当移动一位后最高位不同了为 1，感觉时强化版的 CF。有 jo 和 jno</li>\n<li>PF，奇偶校验位，偶数为 1，jp 和 jnp 和 jpe（parity even 的意思）和 jpo（parity odd 的意思）</li>\n<li>AF，辅助进位，加减法时第三位向第四位借位或进位置 1，与 BCD 有关<br />\n控制标志</li>\n<li>IF 禁止硬件中断，IF=0 禁止，cli（clear interrupt），sti</li>\n<li>TF（Trap flag），位于第八位，设置 CPU 运行模式，TF=1 为单步模式，每一条指令后会跟 int 01h ；另一个是常规模式，只能通过<br />\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pushf</span><br><span class=\"line\">pop ax</span><br><span class=\"line\">or ax,100h</span><br><span class=\"line\">push ax</span><br><span class=\"line\">popf</span><br></pre></td></tr></table></figure><br />\n 来设置，不能用单条指令设置</li>\n</ul>\n<h3 id=\"端口\"><a class=\"anchor\" href=\"#端口\">#</a> 端口</h3>\n<p>CPU 不能直接控制 I/O 设备，必须要向相关端口发送信号才能输出控制信号到端口，也必须读取信号才能获取信息。<br />\n端口地址独立于内存地址，仅有 16 位偏移地址， <code>[0000h,0FFFFh]</code> , 读写指令为 in,out 如 in al,61h,out 21h,al 一个是读入一个是输出</p>\n<h2 id=\"汇编语言源程序格式\"><a class=\"anchor\" href=\"#汇编语言源程序格式\">#</a> 汇编语言源程序格式</h2>\n<h3 id=\"三类语句\"><a class=\"anchor\" href=\"#三类语句\">#</a> 三类语句</h3>\n<ul>\n<li>指令语句</li>\n<li>伪指令语句</li>\n<li>汇编指示语句<br />\n伪指令定义数组或变量，数组名变量名以及类型在编译后都会消失，main, 这种函数和标号是这个伪指令<br />\n指示语句告诉编译器如何编译程序 segment 之类的还有 assume 还有.386 还有 end main 都是指示语句</li>\n</ul>\n<h3 id=\"段的定义-假设与引用\"><a class=\"anchor\" href=\"#段的定义-假设与引用\">#</a> 段的定义、假设与引用</h3>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">segmentname segement   [use] [align] [combine] [&#x27;class&#x27;]</span><br><span class=\"line\"> statements</span><br><span class=\"line\">segmentname ends</span><br></pre></td></tr></table></figure><br />\n 段定义开始和结束应一致，段名与变量名数组名和标号名规范一致：不能以数字开头，可以有三个特殊字符、英文字母、数字和下划线，具体看 53 页</p>\n<ul>\n<li>use 表示偏移地址宽度，use32 表示偏移地址为 32 位宽度。开头有.386 则默认 use32.</li>\n<li>align 表示对齐方式，可以为 byte word dword para page 这五个关键字，para 是 16 字节，页是 256 字节貌似是平方 emmm，省略的话默认 para，对齐方式是指段首地址能被这个 align 整除，如果不行就会对前一个段补 00h。如果 align 不为 para 可能造成首字节偏移地址不为 0, 此时 align 为 byte，且这个段和上个段首地址相同</li>\n<li>’class‘表示类别名可变且须以单引号括起来，这个表示 link 是在 exe 文件中重排顺序以达到邻近。</li>\n<li>combine 可能为 public 和 stack 用于代码和数据段定义，段名相同类别名相同合并类型为 public 的连接时会合成一个段。而类型为 stack 的会合并为一个堆栈段，ss 指向段头，sp 表示长度，如果不存在同名就可以省去 public。但堆栈段不能省区 stack，否则会被当作普通数据段，ss 会初始化为首段，sp 为 0</li>\n</ul>\n<h4 id=\"段定义的简化格式\"><a class=\"anchor\" href=\"#段定义的简化格式\">#</a> 段定义的简化格式</h4>\n<p>其实就是少了 <code>[]</code>  内容然后堆栈段还是有 stack，一般是 db 400h dup (0),dw 200h dup (0)<br />\n 第二个是重复个数，dup 是 duplicate（重复）的意思，里面初始化为 0</p>\n<h4 id=\"段的假设\"><a class=\"anchor\" href=\"#段的假设\">#</a> 段的假设</h4>\n<p>就是 assume segreg:segmentname segreg 就是段寄存器，后面的是段名。这句话并不是赋值作用，而是帮助编译源程序时将对应变量和标号段地址替换成关联寄存器。就是把 data 换成 ds，code 换成 cs。</p>\n<h4 id=\"段的引用\"><a class=\"anchor\" href=\"#段的引用\">#</a> 段的引用</h4>\n<p>可以用两种形式：</p>\n<ul>\n<li>段名</li>\n<li>seg 变量名或标号名（成员的父亲嘛）</li>\n</ul>\n<h3 id=\"程序的结束\"><a class=\"anchor\" href=\"#程序的结束\">#</a> 程序的结束</h3>\n<h4 id=\"源程序的结束\"><a class=\"anchor\" href=\"#源程序的结束\">#</a> 源程序的结束</h4>\n<p>end labelname 指定程序首条指令的位置，IP 会赋值到该偏移地址，CS 会赋值到该标号段地址，如果缺少 labelname IP 等于 0，CS 等于代码段段址，从代码段首条指令开始运行，其实根本找不到代码段</p>\n<h4 id=\"源程序的终止\"><a class=\"anchor\" href=\"#源程序的终止\">#</a> 源程序的终止</h4>\n<p>mov ah,4Ch<br />\nmov al, 返回码<br />\n int 21h<br />\n 返回给父程序（调用该程序的本文指 dos 系统），不调用这个终止会继续执行然后死机</p>\n<h3 id=\"汇编语句的语法成分\"><a class=\"anchor\" href=\"#汇编语句的语法成分\">#</a> 汇编语句的语法成分</h3>\n<p>三类语句的格式<br />\n name mnemonic operand ; comment<br />\nmain:mov ax,data<br />\nmain 是 name mov 是 mnemonic operand 是 ax，data 有点奇怪的 #奇怪</p>\n<ul>\n<li>name 称为名字像，通常指各种名字，大多数语句不用名字项；</li>\n<li>mnemonic 为助记符项目、mov add jmp segment assume end 和 db dw 这些</li>\n<li>operand 成为操作数项目，类型和个数决定于指令，依赖助记符项目</li>\n<li>comment 注释，多行注释用 #（可以换成 % | 这些字符注释内容不能含有标记符）或者 IF 0 ENDIF<br />\n 一行最多一句语句，可用空白符隔开</li>\n</ul>\n<h4 id=\"常数与常数表达式\"><a class=\"anchor\" href=\"#常数与常数表达式\">#</a> 常数与常数表达式</h4>\n<p>整数浮点数和字符常数和字符串常数<br />\n整数 177Q,11B,0,3Fh   Q 表示八进制<br />\n浮点数 x dd 3.14  float<br />\ny dq 1.6E-307  double<br />\nz dt 3.14159E4096 long double<br />\n 字符数 和 py 是一样的，单引号和双引号括起来的都一样 'A' 和 &quot;A&quot; 都一样<br />\n字符串常数 '' 或 &quot;&quot; 括起来的一串字符，并不包含 00h<br />\n 其实 s db'h','e' 等同于 s db ’he‘</p>\n<h5 id=\"常数表达式\"><a class=\"anchor\" href=\"#常数表达式\">#</a> 常数表达式</h5>\n<p>看下 51 吧，其实就是 +- <code>*</code> / 加上 mod 和 shr 还有 not 还有 offset 还有 seg<br />\n 常量表达式的 xor 之类的与 xor 无关，只是常数表达式的算法，然后负号这些寄存器也没有，同时寄存器一行不能像常数一样写多个表达式</p>\n<h5 id=\"符号常数\"><a class=\"anchor\" href=\"#符号常数\">#</a> 符号常数</h5>\n<p>用符号形式表示的常数，EQU 和 = 可以用来定义<br />\n symbol equ expression<br />\nsymbol = expression<br />\n 其实就是个 const 变量，不过 = 和 equ 有区别，= 只能是数值或字符类型常数或表达式，同一符号可多次定义，equ 还允许是字符串，甚至汇编语言语句，感觉像宏啊，而且不可以多次定义<br />\n比如 exitfun equ &lt;mov ah,4Ch&gt;，这个 &lt; 我也不知道为什么，可能是为了表示函数吧，其它表示字符串和常数就不用<br />\n之后就可以直接写 exitfun</p>\n<h4 id=\"变量与标号定义及应用\"><a class=\"anchor\" href=\"#变量与标号定义及应用\">#</a> 变量与标号定义及应用</h4>\n<p>变量标号取名规则：</p>\n<ul>\n<li>不能数字开头</li>\n<li>$ 与？不能单独作为变量名或标号名</li>\n<li>包含字符最多 31</li>\n<li>缺省情况下，变量名及标号名不区分大小写（可通过 masm /Ml 源程序名 来强制区分）</li>\n<li>不能重复定义</li>\n<li>不能与指令名、伪指令名、汇编指示指令名相同</li>\n</ul>\n<h5 id=\"变量定义\"><a class=\"anchor\" href=\"#变量定义\">#</a> 变量定义</h5>\n<p>变量名 db|dw|dd|dq|dt 初始值<br />\n可以用 dup 初始化相同值<br />\n <code>abc db 100 dup(0)</code>  dup 表示重复，100 表示重复次数，而非数组大小<br />\n dup 允许嵌套，如： <code>y db 2 dup('a',3 dup('B'),'C')</code></p>\n<h5 id=\"标号定义\"><a class=\"anchor\" href=\"#标号定义\">#</a> 标号定义</h5>\n<p>其实就是 labelname:, 可以被 call 被 jmp 被 loop，我们也可以用伪指令 label 来定义标号<br />\n <code>labelname label near|far|byte|word|dword|qword|tbyte</code> <br />\nnear|far 这些都是标号类型，表示近标号，远标号，字节，字，双字，四字，十字节，牵连个是标号类型，后 5 个是变量类型<br />\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">abc label byte ;</span><br><span class=\"line\">db 1,3,4;其实就是abc db 1,3,4</span><br><span class=\"line\">far_away label far ;</span><br><span class=\"line\">  ....//这个就是函数</span><br></pre></td></tr></table></figure><br />\n 这个 label byte 后面可以不跟初始值，相当于声明这个变量但不分配内存空间，abc 就是接下来数组名字或者数组就是初始值，其实就是 abc 就是那一块地址，没有内容，不占空间，这样子可以出现定义多种类型变量，就像 union<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a label byte</span><br><span class=\"line\">b label word</span><br><span class=\"line\">db 12h,34h</span><br></pre></td></tr></table></figure><br />\n 由于小端规则，所以 b 为 3412h。<br />\n近标号转换为仅有偏移地址，远标号转换为带段地址和偏移地址。<br />\n对应短跳和远眺，短跳指令 3 字节，远跳指令 5 字节，这个分类取决于 jmp 起点和目标是否在同一个段。指令中加入 far ptr 和 near ptr 属于强制转换。跳向不在同段的 label near 要在指令中加入 far ptr ，向前引用不在同一段的（源程序当前代码下方）label far ptr 也要在指令中加入 far ptr，比 c 烦。</p>\n<h5 id=\"变量引用-2\"><a class=\"anchor\" href=\"#变量引用-2\">#</a> 变量引用</h5>\n<p>在数据段，var 和 offset var 可以表示 dw 操作数下 var 的近地址，var 还可以作为 dd 操作数下 var 的远地址，在代码段只能用 offset var 表示偏移地址，但在数据段可以表示近指针，远指针。<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xyz db &#x27;w&#x27;</span><br><span class=\"line\">addr1 dw offset xyz</span><br><span class=\"line\">addr3 dd xyz</span><br></pre></td></tr></table></figure><br />\n 这个 dd 属性要想赋值给两个 16 位寄存器得用 word ptr 强制转换</p>\n<h3 id=\"位置计数器\"><a class=\"anchor\" href=\"#位置计数器\">#</a> 位置计数器</h3>\n<p>编译器会用位置计数器的变量来记录段内变量和标号偏移地址，段定义开始自动清零，每条指令后宽度会加到位置计数器里，$ 可以得到当前位置计数器的值，我怀疑这个就是你的位置编号。其实就是当前位置的偏移地址详细看 58 页</p>\n<h2 id=\"调试\"><a class=\"anchor\" href=\"#调试\">#</a> 调试</h2>\n<p>全球唯一能调试保护模式用户程序的调试器 - Bochs Enhanced Debugger, 本身相当于一个虚拟的，</p>\n<h3 id=\"软件断点\"><a class=\"anchor\" href=\"#软件断点\">#</a> 软件断点</h3>\n<p>通过改写指令首字节为 0CCh 设置的指令执行断点，对应 int3h, 使调试器获得控制权。<br />\n单步执行会在指令执行后调用 int 1h，int 1h 会接着改写首字节为 0CCh，</p>\n<h3 id=\"硬件断点\"><a class=\"anchor\" href=\"#硬件断点\">#</a> 硬件断点</h3>\n<p>是通过把指令首字节地址、变量地址写入调试器寄存器而设置的指令执行断点或变量执行断点，由于 CPU 能保存断点地址寄存器只有 4 个，所以硬件断点的数量最多只有 4 个，硬件断点只会监控而不改变值，所以容易找出数组越界这类问题。S-ICE 支持四个硬件断点，Bochs 支持功能上类似的 16 个指令执行断点和 16 个变量读写断点</p>\n<h3 id=\"debug调试程序\"><a class=\"anchor\" href=\"#debug调试程序\">#</a> debug 调试程序</h3>\n<p>p64 和 65 和 p67 和 68-69，因为上课只讲了 td<br />\ntasm 和 tlink 可以看到源码但 masm 和 link 就不行<br />\n可以改变指令，也可以改变数据，但是字母开头前缀要加 0，二进制 B 后缀，十进制 D 后缀。</p>\n<h2 id=\"指令系统\"><a class=\"anchor\" href=\"#指令系统\">#</a> 指令系统</h2>\n<h3 id=\"指令结构\"><a class=\"anchor\" href=\"#指令结构\">#</a> 指令结构</h3>\n<p>指令 = 操作码 + 操作数<br />\n 0-2 个操作数，分别叫元操作数指令，单操作数指令，双操作数指令<br />\n操作数有常数，寄存器，变量</p>\n<h4 id=\"数据传输指令\"><a class=\"anchor\" href=\"#数据传输指令\">#</a> 数据传输指令</h4>\n<p>mov dest,src</p>\n<ul>\n<li>不影响标志位</li>\n<li>dest,src 不能全为内存变量</li>\n<li>等宽原则</li>\n<li>常数或段寄存器不能赋值给段寄存器</li>\n<li>不能对 cs，IP,FL 赋值<br />\n push op<br />\n 会自动判断大小的，然后移动 bp 指针</li>\n<li>不能移动 8 位宽度操作数和常数</li>\n<li>不影响标志位<br />\n pop op<br />\n 同 push 一样<br />\n xchg op1，op2</li>\n<li>不能有段寄存器，不影响标志位，同时不能两个 memory 互相操作</li>\n</ul>\n<h4 id=\"输入输出指令\"><a class=\"anchor\" href=\"#输入输出指令\">#</a> 输入输出指令</h4>\n<p>in al,port</p>\n<ul>\n<li>当 port&gt;0FFh 后，只能使用 in al,dx 格式，不能使用常数了，&lt;= 都可以，这个怎么和 80836 的 shl 差不多<br />\n out port,al</li>\n<li>与 in 一致</li>\n</ul>\n<h4 id=\"地址传输命令\"><a class=\"anchor\" href=\"#地址传输命令\">#</a> 地址传输命令</h4>\n<ol>\n<li>lea dest,src<br />\nlea reg,mem；load effective address<br />\n 就是取 src 的地址给 dest</li>\n<li>lds dest,src 取出远指针，段地址给 ds，偏移地址给 dest<br />\n <code>lds si,es:[di]</code></li>\n<li>les dest ,src 就是 ds 换成了 es，多为 les di</li>\n</ol>\n<h4 id=\"标志寄存器传送指令\"><a class=\"anchor\" href=\"#标志寄存器传送指令\">#</a> 标志寄存器传送指令</h4>\n<p>这些指令都是对 FL 操作<br />\n<strong> lahf</strong><br />\n 把 fl 低 8 位给 ah，为啥低给高 8 位我也不清楚<br />\n load AH with flags<br />\n<strong>sahf</strong><br />\n 把 ah 赋值给 fl 的低八位<br />\n store AH in flags<br />\n<strong>pushf</strong><br />\n 就是 push fl，但是 push 不能用来操作 fl<br />\n<strong>popf</strong><br />\n 一样的<br />\n<strong> pushfd</strong><br />\n 把 EFLpush 进去<br />\n<strong> popfd</strong></p>\n<h4 id=\"转换指令\"><a class=\"anchor\" href=\"#转换指令\">#</a> 转换指令</h4>\n<p><strong>cbw</strong>(Convert Byte to Word)<br />\n 把 al 符号扩充到 ax<br />\n<strong>cwd</strong>(Convert word to double word)<br />\n ax 扩充到 dx:ax 中，：表示连接符，这个扩充到 dx 是因为一开始的 x86 没有 32 位<br />\n<strong> cdq</strong>(Convert double word to quadruple word)<br />\n<strong>movsx dest,src</strong>（move by sign extension）(只能扩充到 16 位和 32 位寄存器，src 可以是 mem8 和 mem16)<br />\n 把 src 符号扩充到 dest，src 可包含内存变量，但是位数偏低，可能要 ptr<br />\n<strong>movzx dest,src</strong> ( move by zero extension)<br />\n 一样的格式，只不过零扩充</p>\n<h4 id=\"换码指令\"><a class=\"anchor\" href=\"#换码指令\">#</a> 换码指令</h4>\n<p><strong>xlat</strong><br />\n 把 byte ptr ds: <code>[bx+AL]</code>  赋值给 AL<br />\n 含义 translate 确实没懂啊</p>\n<h4 id=\"加法指令\"><a class=\"anchor\" href=\"#加法指令\">#</a> 加法指令</h4>\n<p>__add dest,src__影响 CF<br />\n<strong>inc  op</strong><br />\n 不影响 CF<br />\n<strong>adc dest,src</strong><br />\n 带进位加 add with carry</p>\n<h4 id=\"减法指令\"><a class=\"anchor\" href=\"#减法指令\">#</a> 减法指令</h4>\n<p><strong>sub</strong><br />\n<strong>sbb</strong><br />\n 带借位减，dest-src-CF<br />\nsubtract with borrow 用于 ds：ax 中 ax 借位后操作 ds<br />\n<strong>dec</strong><br />\n 不影响 CF<br />\n<strong>neg</strong><br />\n 计算 op 相反数<br />\n<strong> cmp op1,op2</strong><br />\n 没想到吧，比较也在这，不保存差值，但会影响状态标志</p>\n<h4 id=\"jcc跳转指令\"><a class=\"anchor\" href=\"#jcc跳转指令\">#</a> JCC 跳转指令</h4>\n<p><code>ja</code>   <code>jae</code>  jump above （or equal) CF <code>==0</code>  且 ZF <code>==0</code>  无借位且不等，注意只写了 ja<br />\n <code>jb jbe</code>  jump below                    CF <code>==1</code> || ZF <code>==1</code>  有借位或相等，注意只写 jbe<br />\n <code>je jne</code>                                         ZF<br />\n <code>jg</code>  jump if greater 这个是有符号大于  <code>SF==OF&amp;&amp; ZF==0</code> <br />\n <code>jge</code>   <code>SF==OF</code> <br />\n <code>jl jle</code>  有符号小于</p>\n<h4 id=\"乘法指令\"><a class=\"anchor\" href=\"#乘法指令\">#</a> 乘法指令</h4>\n<p><strong>mul src</strong> 非符号乘法<br />\n imul src 带符号乘法 signed mul<br />\ndiv src 除数为 0 或商无法保留会出现触发溢出，此时 CPU 会在除法指令上方插入一条 00H 指令<br />\n idiv op //signed divide</p>\n<h3 id=\"浮点运算指令\"><a class=\"anchor\" href=\"#浮点运算指令\">#</a> 浮点运算指令</h3>\n<p>fadd,fsub,fmul,fdiv,fild,fld,fst,fstp，不接受寄存器</p>\n<h3 id=\"8个小数寄存器\"><a class=\"anchor\" href=\"#8个小数寄存器\">#</a> 8 个小数寄存器</h3>\n<p>st(0),st(1),st(2),st(3),st(4),st(5),st(6),st(7)<br />\n 这 8 个宽度都是 80 位，<br />\n8 个小数寄存器构成一个 FPU 堆栈，堆栈顶端小数寄存器物理编号记作 TOP，顶端逻辑编号恒为 0，st (i) 中 i 为逻辑编号。物理编号 p：p=(TOP+i)%8, 具体看 p100<br />\nst (0) 可以简写为 st<br />\nfld 和 fild 会装入 FPU 堆栈里，这个就是使用一次堆栈顶物理编号 - 1module8,fstp 会弹出，此时是 + 1<br />\nTD 中在 view-&gt;Numeric processor 可以在代码窗下方查看 8 个小数寄存器</p>\n<h3 id=\"十进制调整指令\"><a class=\"anchor\" href=\"#十进制调整指令\">#</a> 十进制调整指令</h3>\n<p>BCD（Binary Coded Decimal) 指用二进制编码表示十进制数。分为压缩 BCD 和非压缩 BCD，压缩使用 4 个二进制位表示一个十进制，非压缩使用 8 个。<br />\n如十进制 37 用 37h 和 0307h 的区别。</p>\n<h4 id=\"压缩bcd调整指令\"><a class=\"anchor\" href=\"#压缩bcd调整指令\">#</a> 压缩 BCD 调整指令</h4>\n<p><code>daa</code>  用来将 AL 表示为十进制<br />\n这个换算有点离谱，建议看看 p102-105，如第一位大于等于 A，那么加 6，第二位大于等于 A，第二位加 60h<br />\ndaa 是将两个 BCD 的十六进制加法出来的 al 转换为十进制<br />\n das 把加变成减，也就是减法调整<br />\n #可以试试能不能直接十六位换成十进制</p>\n<h3 id=\"非压缩bcd指令\"><a class=\"anchor\" href=\"#非压缩bcd指令\">#</a> 非压缩 BCD 指令</h3>\n<p>aaa，AH+1,AL+6（ASCII adjust after addition<br />\naas 减法调整，把 + 变成 -<br />\naam 乘法调整 AH=AL/10 AL=AL%10<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mul bl</span><br><span class=\"line\">aam</span><br></pre></td></tr></table></figure><br />\naad 除法<br />\n AH=0,AL=(AH <code>*</code> 10+AL)&amp; 0FFh；<br />\n# 有点离谱</p>\n<h3 id=\"逻辑运算指令和移位指令\"><a class=\"anchor\" href=\"#逻辑运算指令和移位指令\">#</a> 逻辑运算指令和移位指令</h3>\n<p>and mem，reg    || and reg，idata||and mem，idata 不能 mem 比 mem<br />\nor<br />\nxor<br />\nnot 取反，单元 not reg<br />\ntest 不记录结果但会影响状态标志的 and 指令</p>\n<h2 id=\"字符串操作\"><a class=\"anchor\" href=\"#字符串操作\">#</a> 字符串操作</h2>\n<p>目标都是 es：di<br />\nmovs (字符串复制) movsb ,movsw,movsd (从 ds 复制到 es)<br />\n cmps（字符串比较）<br />\nscas（搜索字符串）scas 搜索 al，ax，eax 的值<br />\n stos（写入字符串）<br />\nlods（读取字符串）<br />\nrep（重复）<br />\nrepe（相等重复）<br />\nrepz<br />\nrepne<br />\nrepnz<br />\nrepe=repz<br />\n 顺序复制字符串<br />\n ds：si<br />\nes：di 调好值<br />\n然后 cx=slen<br />\ncld# 把 DF 清 0，正方向<br />\n rep movsb di+=1<br />\nrep movsw di+=2<br />\nrep movsd 复制字符串<br />\n repe cmpsb<br />\nrepne cmpsb 比较两个</p>\n<p>repescasb<br />\nscasw 扫描 es:di</p>\n<p>stosw<br />\nal，ax，eax 写入字符串 es：di 指向字符串</p>\n<p>lodsb  将 ds：【si】写入 al</p>\n<h3 id=\"控制转移指令\"><a class=\"anchor\" href=\"#控制转移指令\">#</a> 控制转移指令</h3>\n<p>jmp 分为三类：<br />\n短跳（short jump）跳转指令用一个字节表示<br />\n近跳（near jump）跳转距离或目标地址用一个字表示<br />\n远眺（far jump）目标地址用 1 个远指针表示</p>\n<h4 id=\"短跳\"><a class=\"anchor\" href=\"#短跳\">#</a> 短跳</h4>\n<p>0EBh，idata8<br />\n 机器码 0EBh，<br />\n跳转距离是目标地址和下条指令偏移地址之差<br />\n距离为 <code>[-128,127]</code> <br />\n idata = 标号 -(当前偏移地址 + 2)</p>\n<h4 id=\"近跳\"><a class=\"anchor\" href=\"#近跳\">#</a> 近跳</h4>\n<p>0E9h，idata16L8，idataH8<br />\nidata = 标号 -（$+3)<br />\n 近跳也可以写成 <strong>jmp reg16</strong>  <strong>jmp mem16</strong></p>\n<h4 id=\"远跳\"><a class=\"anchor\" href=\"#远跳\">#</a> 远跳</h4>\n<p>0EAh，idata32L16,....<br />\n 操作：IP=idata32L16<br />\nCS=idata32H16<br />\n<strong>jmp far ptr 标号</strong>，只能跳到标号，要做到指定位置，只能用机器码实现，参考 p134.<br />\n<strong>jmp mem32</strong></p>\n<h3 id=\"条件跳转\"><a class=\"anchor\" href=\"#条件跳转\">#</a> 条件跳转</h3>\n<p>参考 p135-136<br />\n 有个 <strong>jcxz</strong> jump if cx is zero<br />\njecxz 不知道为啥有这个</p>\n<h3 id=\"循环\"><a class=\"anchor\" href=\"#循环\">#</a> 循环</h3>\n<p><strong>loop 标号</strong>，根据 cx 值操作，但是 cx-- 在前面，才比较 cx <code>==0</code> , 也许这就是 jcxz 的作用，来在 loop 前表示 0 的情况跳出<br />\n<strong> loopz 标号</strong> 同时会检测 ZF 是否为 0，如果不为 0 也结束，可以用 test bx，ax 来操作 ZF<br />\n<strong>loopnz 标号</strong></p>\n<h3 id=\"调用与返回\"><a class=\"anchor\" href=\"#调用与返回\">#</a> 调用与返回</h3>\n<h4 id=\"call-near-ptr-dest\"><a class=\"anchor\" href=\"#call-near-ptr-dest\">#</a> call near ptr dest</h4>\n<p>0E8h,idata16L8,idata16H8<br />\n 此时 SP=SP-2 来保存这个下一个地址<br />\n<strong> call near ptr 标号</strong>，idata16 = 标号 -（$+3)<br />\n<strong>call reg16</strong>   <strong>call mem16</strong> 这两个也是一样的</p>\n<h4 id=\"retn-retn-idata16\"><a class=\"anchor\" href=\"#retn-retn-idata16\">#</a> retn /retn idata16</h4>\n<p><strong>retn</strong>   back_addr= word ptr ss: <code>[sp]</code>      SP=SP+2     IP=back_addr<br />\n<strong>retn idata16</strong> SP=SP+2+idata16 其他没区别<br />\n代码看 p141</p>\n<blockquote>\n<p>注意：在用标号定义的函数及用 <code>函数名 proc ... 函数名 endp</code> <br />\n 或 <code>函数名 proc near|far ... 函数名 endp</code>  中，ret 等于 retf，故 retn 不能简写成 ret</p>\n</blockquote>\n<h4 id=\"call-far-ptr-dest\"><a class=\"anchor\" href=\"#call-far-ptr-dest\">#</a> call far ptr dest</h4>\n<p>远调用，目标地址是 dest<br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>9</mn><mi>A</mi><mi>h</mi><mtext>，</mtext><mi>i</mi><mi>d</mi><mi>a</mi><mi>t</mi><msub><mi>a</mi><mrow><mi>L</mi><mn>16</mn></mrow></msub><mo separator=\"true\">,</mo><mi>i</mi><mi>d</mi><mi>a</mi><mi>t</mi><msub><mi>a</mi><mrow><mi>H</mi><mn>16</mn></mrow></msub></mrow><annotation encoding=\"application/x-tex\">9Ah，idata_{L16},idata_{H16}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">9</span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\">h</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">L</span><span class=\"mord mtight\">1</span><span class=\"mord mtight\">6</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord\"><span class=\"mord mathnormal\">a</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mtight\">1</span><span class=\"mord mtight\">6</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span><br />\n 还可以 call mem32<br />\nidata32 不能是常数，指定常数只能用 5 字节机器码得到<br />\n retf<br />\n 远返回<br />\n retf idata16</p>\n<p>需要注意向前调用</p>\n<h3 id=\"中断指令和中断返回指令-intint-3intoiret\"><a class=\"anchor\" href=\"#中断指令和中断返回指令-intint-3intoiret\">#</a> 中断指令和中断返回指令 int,int 3,into,iret</h3>\n<p>int n 调用的目标地址是一个 32 位的远指针，这个远指针被称作 int n 的中断向量保存在 0000:n <code>*</code> 4 处，int 01g 的中断向量是 dword ptr 0: <code>[4]</code>  一共有 100h（256）个中断向量</p>\n<p><strong>int idata8(interrupt)</strong><br />\n0CDh,idata8<br />\nold_fl=FL;<br />\nIF=0<br />\nTF=0<br />\nSP=SP-6<br />\nword ptr SS: <code>[SP]</code> =IP+2<br />\nSS: <code>[SP+2]</code> =CS<br />\nSS: <code>[SP+4]</code> =old_fl<br />\n 上面都要加 word ptr</p>\n<p><strong>int 3</strong> 软件断点<br />\n 0CCh<br />\nss: <code>[sp]</code> =IP+1</p>\n<p><strong>into</strong> 溢出中断 (interrupt on overflow)<br />\n0CEh</p>\n<p><strong>iret</strong> 中断返回 (interrupt return)<br />\nback_ip=ss： <code>[sp]</code> <br />\nback_cs...<br />\nSP=SP+6；<br />\nFL=back_fl...<br />\n 就是 int idata8 的返回</p>\n<h2 id=\"函数定义\"><a class=\"anchor\" href=\"#函数定义\">#</a> 函数定义</h2>\n<p>两种形式定义函数:</p>\n<ul>\n<li>用标号定义函数</li>\n<li>用 proc 定义函数<br />\n标号定义：标号名：<br />\nretn；也可以写成 ret<br />\n 标号名 label near<br />\nretn；也可写成 ret<br />\n 标号名 label far<br />\nretf ；也可以写成 ret<br />\nproc 定义函数：1.<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数名 proc near  #near可简略不写</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tretn</span><br><span class=\"line\">函数名 endp</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li></li>\n</ol>\n</li>\n</ul>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数名 proc far...</span><br><span class=\"line\">\tretf</span><br><span class=\"line\">函数名 endp</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"传递参数\"><a class=\"anchor\" href=\"#传递参数\">#</a> 传递参数</h3>\n<ul>\n<li>寄存器传递参数</li>\n<li>变量传递参数</li>\n<li>堆栈传递参数<br />\n看 p150 程序。<br />\n全局变量就是 db 中有个变量<br />\n变量压入堆栈，不过开头都要 push bp，mov bp，sp，这样才能通过 bp 访问变量和参数，函数参数通过 <code>[bp+idata]</code>  访问，动态变量通过 <code>[bp-idata]</code>  访问（其实就是局部变量）<br />\ncdecl 采取从右向左参数放入堆栈，pascal 采用从左向右，还有 stdcall 详情看 p153-156</li>\n</ul>\n<blockquote>\n<p>动态变量通过初始化框架后 (push bp、mov bp,sp) 后在 sub bp,idata, 此时可通过 <code>[bp-idata]</code>  来访问了。</p>\n</blockquote>\n<h2 id=\"中断程序设计\"><a class=\"anchor\" href=\"#中断程序设计\">#</a> 中断程序设计</h2>\n<p>首先 cmp 之后接 jmp 指令会在中间产生 int 8h 的中断，具体看 p161<br />\n# 具体为什么问问钟神<br />\n程序得看看 p160<br />\n 还有键盘中断 p166<br />\n 解密指令 p168</p>\n<h3 id=\"驻留程序设计\"><a class=\"anchor\" href=\"#驻留程序设计\">#</a> 驻留程序设计</h3>\n<p>如果我们希望一个程序的中断向量影响像一个程序，不应该使用 int 21h 的 4Ch 号功能，而应该使用 int 21h 的 31h 号功能（Terminate &amp;Stay Resident,TSR),<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AH=31h</span><br><span class=\"line\">AL=返回码</span><br><span class=\"line\">DX=从PSP起需要保留的内存块的节长度</span><br></pre></td></tr></table></figure><br />\n 节长度 para 是 10 字节 / 节。p171 页教你开挂</p>\n<h2 id=\"文件操作\"><a class=\"anchor\" href=\"#文件操作\">#</a> 文件操作</h2>\n<p>与内存相关的 dos 中断调用</p>\n<h3 id=\"内存分配\"><a class=\"anchor\" href=\"#内存分配\">#</a> 内存分配</h3>\n<table>\n<thead>\n<tr>\n<th>功能号</th>\n<th>功能</th>\n<th>参数</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>48h</td>\n<td>分配内存</td>\n<td>AH=48H;BX = 待分配内存块的节长度</td>\n<td>成功时 ax 为段地址，CF=0，失败时 CF=1</td>\n</tr>\n<tr>\n<td>49h</td>\n<td>释放内存</td>\n<td>AH=49h，ES = 待释放内存块的段地址</td>\n<td>成功时 CF=0，失败时 CF=1</td>\n</tr>\n<tr>\n<td>4Ah</td>\n<td>重分配内存</td>\n<td>BX = 节长度</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>与文件操作相关</p>\n<table>\n<thead>\n<tr>\n<th>功能号</th>\n<th>功能</th>\n<th>参数</th>\n<th>返回值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>3Ch</td>\n<td>创建文件</td>\n<td>CX = 文件属性；DS:DX-&gt; 文件名</td>\n<td>成功 ax 返回 handle，CF=0, 失败 ax 为错误码，CF=1</td>\n</tr>\n<tr>\n<td>3Dh</td>\n<td>打开文件</td>\n<td>AL 为打开方式</td>\n<td></td>\n</tr>\n<tr>\n<td>3Eh</td>\n<td>关闭文件</td>\n<td>BX=handle</td>\n<td></td>\n</tr>\n<tr>\n<td>3Fh</td>\n<td>读文件</td>\n<td>CX: 待读字节数</td>\n<td>成功时，AX 为已读字节数；失败 ax 为错误码‘’</td>\n</tr>\n<tr>\n<td>40H</td>\n<td>写文件</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>42h 移动文件指针</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"混合语言编程\"><a class=\"anchor\" href=\"#混合语言编程\">#</a> 混合语言编程</h2>\n<p>tcc 编译<br />\n int x=10;<br />\nc 语言中可含有 asm mov ax, <code>[x]</code> ;<br />\n <code>__</code> declspec(naked) int f(int a,int b){<br />\n <code>__</code> asm{<br />\npush ebp<br />\n...<br />\n}<br />\n}<br />\nint main(){</p>\n<p>}<br />\n 感觉不好写，直接看 p180-181 吧；<br />\n主要段名注意是_TEXT segment byte public 'CODE'<br />\n 然后要恢复 bx，bp，si，di<br />\ntcc -v caller.c caller.obj</p>\n<h2 id=\"int-h\"><a class=\"anchor\" href=\"#int-h\">#</a> int ...h</h2>\n<p>首先 mov ah,2<br />\nint 21h 是输出 dl 的字符<br />\n mov ah,9<br />\nint 21h 是输出 ds：dx 指向的以 '$' 结尾的字符串</p>\n",
            "tags": [
                "笔者是菜鸟，上课不记笔记，因而只有补天笔记了"
            ]
        },
        {
            "id": "https://memoryoffish.github.io/2024/04/28/mips/",
            "url": "https://memoryoffish.github.io/2024/04/28/mips/",
            "title": "计原笔记",
            "date_published": "2024-04-28T09:15:00.000Z",
            "content_html": "<h1 id=\"前记\"><a class=\"anchor\" href=\"#前记\">#</a> 前记</h1>\n<p>练习题：非课后习题，为书中小测题，答案在每章习题后<br />\n习题：课后习题。<br />\n本篇基本涵盖书中知识点但不包括习题和书上的练习题，老师课上喜欢出练习题，不过听说以往的小测题目都是一样的，可参考往年智云，历年题改变较大，选择题基本没有参考价值，建议做做大题，无聊时做做选择题也不是不行，ppt 一定要看，以下内容可以直接当作书来看（因为你看书也记不住多少还浪费时间），时间多就在看练习题和课后习题，时间少看 ppt，基本平时课听懂了，这门课补天还是好补的。</p>\n<h1 id=\"考试回忆\"><a class=\"anchor\" href=\"#考试回忆\">#</a> 考试回忆</h1>\n<p>大题目多了一道信号如何添加，然后有一道反码补码的计算和一个写机器码的题目，一道写代码，选择题来自 ppt，有一道奇怪的下列选项是否需要硬件和软件支持（为书中练习题）。</p>\n<h1 id=\"性能\"><a class=\"anchor\" href=\"#性能\">#</a> 性能</h1>\n<p 时钟频率=\"\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>性能</mtext><mo>=</mo><mfrac><mn>1</mn><mtext>执行时间</mtext></mfrac></mrow><annotation encoding=\"application/x-tex\">性能=\\frac{1}{执行时间}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">性</span><span class=\"mord cjk_fallback\">能</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.190108em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.845108em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">执</span><span class=\"mord cjk_fallback mtight\">行</span><span class=\"mord cjk_fallback mtight\">时</span><span class=\"mord cjk_fallback mtight\">间</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span><br />\n X 是 Y 的 n 倍快：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mtext>性能</mtext><mi>x</mi></mrow><mrow><mtext>性能</mtext><mi>y</mi></mrow></mfrac><mo>=</mo><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">\\frac{性能x}{性能y}=n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.3534389999999998em;vertical-align:-0.481108em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.872331em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">性</span><span class=\"mord cjk_fallback mtight\">能</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03588em;\">y</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">性</span><span class=\"mord cjk_fallback mtight\">能</span><span class=\"mord mathnormal mtight\">x</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.481108em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span><br />\n 我们用 CPU (执行) 时间来反映在 CPU 花费时间，而非 CPU 工作时间<br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>程序</mtext><mi>C</mi><mi>P</mi><mi>U</mi><mtext>执行时间</mtext><mo>=</mo><mfrac><mrow><mtext>程序的</mtext><mi>C</mi><mi>P</mi><mi>U</mi><mtext>时钟周期数</mtext></mrow><mtext>时钟频率</mtext></mfrac></mrow><annotation encoding=\"application/x-tex\">程序CPU执行时间=\\frac{程序的CPU时钟周期数}{时钟频率}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">程</span><span class=\"mord cjk_fallback\">序</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord cjk_fallback\">执</span><span class=\"mord cjk_fallback\">行</span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">间</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.217331em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.872331em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">时</span><span class=\"mord cjk_fallback mtight\">钟</span><span class=\"mord cjk_fallback mtight\">频</span><span class=\"mord cjk_fallback mtight\">率</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">程</span><span class=\"mord cjk_fallback mtight\">序</span><span class=\"mord cjk_fallback mtight\">的</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">C</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">U</span><span class=\"mord cjk_fallback mtight\">时</span><span class=\"mord cjk_fallback mtight\">钟</span><span class=\"mord cjk_fallback mtight\">周</span><span class=\"mord cjk_fallback mtight\">期</span><span class=\"mord cjk_fallback mtight\">数</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span><br />\n 提升到原来多少是指原来的多少倍<br />\n CPI 每条指令所需平均时钟周期<br />\nCPU时间=\\frac{指令数*CPI}</p>\n<h2 id=\"指令计算机的语言\"><a class=\"anchor\" href=\"#指令计算机的语言\">#</a> 指令：计算机的语言</h2>\n<p>32 个寄存器<br />\n 2 <code>**</code> 30 的存储字</p>\n<h3 id=\"数据传送指令\"><a class=\"anchor\" href=\"#数据传送指令\">#</a> 数据传送指令</h3>\n<p><strong>lw s1,20__\n__sw ` <code>1,20(</code> $`s2)</strong> 值得注意的是，字是 32 位，不同于 x86<br />\n<strong>lh</strong>  半字以及 lhu 半字无符号 ，一个进行符号扩充，一个进行无符号扩充<br />\n<strong> sh</strong><br />\n<strong>lb</strong> 下载一个字节 对应 lbu<br />\n<strong>sb</strong><br />\n<strong>ll</strong> 说是取数，不知道是啥，原子交换第一部分，load linked word<br />\n<strong>sc</strong> store condition word 是上一个的反过来。想起来了，这个是锁的问题。。。</p>\n<h3 id=\"逻辑运算\"><a class=\"anchor\" href=\"#逻辑运算\">#</a> 逻辑运算</h3>\n<p><strong>and</strong><br />\n<strong>or</strong> 注意这都是 R 型指令<br />\n andi<br />\nsll  shift left logical<br />\nsrl</p>\n<h2 id=\"分支语句\"><a class=\"anchor\" href=\"#分支语句\">#</a> 分支语句</h2>\n<p><strong>beq .1,.2,50</strong> 这个 pc=50 <code>*</code> 4+4+pc<br />\nbne<br />\nslt .1,.2,.3 set less than 如果.2 小于.3 那么.1 是 1，反之为 0<br />\nsltu<br />\nslti<br />\nsltiu</p>\n<h2 id=\"跳转语句\"><a class=\"anchor\" href=\"#跳转语句\">#</a> 跳转语句</h2>\n<p>j 2500<br />\njr register<br />\njal 2500 jump and link ra 寄存器存储 pc+4 地址<br />\n <code>#</code> 表示一行的注释</p>\n<h2 id=\"关于寄存器\"><a class=\"anchor\" href=\"#关于寄存器\">#</a> 关于寄存器</h2>\n<p>大量寄存器可能使时钟周期变长<br />\n字起始地址应该是 4 的倍数，这是对齐限制<br />\n将不常使用的变量存回寄存器叫做寄存器换出<br />\n相比存储器，寄存器吞吐率高，访问时间短<br />\n <code>$s0~$s7</code>  映射到寄存器 16~23<br />\n <code>$t0~$t7</code>  映射到 8~15</p>\n<h2 id=\"指令\"><a class=\"anchor\" href=\"#指令\">#</a> 指令</h2>\n<table>\n<thead>\n<tr>\n<th>op</th>\n<th>rs</th>\n<th>rt</th>\n<th>rd</th>\n<th>shamt</th>\n<th>funct</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>6 位</td>\n<td>5 位</td>\n<td>5 位</td>\n<td>5 位</td>\n<td>5 位</td>\n<td>6 位</td>\n</tr>\n</tbody>\n</table>\n<p>R 型指令如上 rs 或 rt 可以等于 rd</p>\n<table>\n<thead>\n<tr>\n<th>op</th>\n<th>rs</th>\n<th>rt</th>\n<th>constant/address</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>6 位</td>\n<td>5 位</td>\n<td>5 位</td>\n<td>16 位</td>\n</tr>\n</tbody>\n</table>\n<p>常数绝对值不得超过 2 <code>**</code> 15<br />\n 对应的 op 不知道要不要考，暂且不写</p>\n<p>mips 里面没有 not，但有 nor（或非）not（a or b） <code>nor a，0</code>  就是对 a 取反，xor（异或）<br />\n做运算时，如果是加法（包括无符号加法) 这类，16 位立即数会符号扩充，如果是异或这类，会零扩充</p>\n<h3 id=\"决策指令\"><a class=\"anchor\" href=\"#决策指令\">#</a> 决策指令</h3>\n<p>beq r1，r2，L1<br />\nbne 这两个叫条件分支<br />\n没有分支目标 / 分支标签的指令序列叫做基本块。编译最初阶段任务是分解基本块出来<br />\n注意没有小于则分支，大于则分支这类说法，因为 slt 可以满足需求 bne</p>\n<h3 id=\"过程\"><a class=\"anchor\" href=\"#过程\">#</a> 过程</h3>\n<p>过程约定：<br />\na0~a3: 传递参数的四个寄存器<br />\n v0~v1: 返回结果的两个值寄存器<br />\n ra: 返回地址寄存器<br />\n jal 会让下一条指令链接到 ra 上<br />\n PC 全名 program counter 程序计数器<br />\n mips 里的 push 是自己先向下移动 sp，再存入数据在 sp 指向块<br />\n在过程中，t0<sub>t9 随便使用，s0</sub>s7 则需要复原。<br />\n不调用其他过程的过程叫叶过程<br />\n由于再次调用原因，我们每个程序一般都要 push ra 和 a0 的，具体如下<br />\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addi $sp,-8</span><br><span class=\"line\">sw $ra,4($sp)</span><br><span class=\"line\">sw $a0,0($sp)</span><br><span class=\"line\">之后复原</span><br><span class=\"line\">lw $a0,4($sp)</span><br><span class=\"line\">lw $a0,0(sp)</span><br><span class=\"line\">addi $sp,8</span><br><span class=\"line\">jr $ra</span><br></pre></td></tr></table></figure><br />\n 不过过程不要求保留 a0<sub>a3，要求保留 ra，sp，s0</sub>s7 还有 sp 之上的栈，这些要求不变<br />\n栈中包含过程中所需寄存器和局部变量的片段叫做过程帧或活动记录。帧指针指向一开始 sp 还未保存时的地方</p>\n<h3 id=\"加锁\"><a class=\"anchor\" href=\"#加锁\">#</a> 加锁</h3>\n<p>交换原语，寄存器把 1 与存储器的 0 交换，视为加锁，如果换出来的是 1，是为解锁失败<br />\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addi $t0,$zero,1</span><br><span class=\"line\">ll $t1,0($s1)</span><br><span class=\"line\">sc $t0,0($t1)//存成返回1，失败返回0，重复循环</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"运算\"><a class=\"anchor\" href=\"#运算\">#</a> 运算</h1>\n<h3 id=\"溢出\"><a class=\"anchor\" href=\"#溢出\">#</a> 溢出</h3>\n<p>add、addi、sub 溢出时会产生异常（也叫中断）（EPC）<br />\n无符号不会溢出，c 语言忽略溢出采用的是无符号<br />\n ALU 算术逻辑单元<br />\n饱和操作指溢出后直接变成最大值<br />\n检测溢出时有符号检测两个数符号和和的符号，无符号检测一个数的取反和和的大小<br />\n $k0 $k1 是用来溢出处理后返回指令地址的</p>\n<h2 id=\"加快乘除法\"><a class=\"anchor\" href=\"#加快乘除法\">#</a> 加快乘除法</h2>\n<p>这章注意 143 和 138 的图，可能要画的</p>\n<h3 id=\"乘法指令\"><a class=\"anchor\" href=\"#乘法指令\">#</a> 乘法指令</h3>\n<p>mult multu<br />\nmips 通过 Hi 和 Lo 这两个寄存器存储积，mflo 和 mfhi 可以将积取出，可以通过检查 hi 来判断是否溢出<br />\n可通过并行加快</p>\n<h3 id=\"除法指令\"><a class=\"anchor\" href=\"#除法指令\">#</a> 除法指令</h3>\n<p>div<br />\ndivu<br />\n 除数开始时置于左 32 位，右移变小，检测是否可以减去，然后判断该位为 0 或 1（通过减后大于 0 小于 0 判断小于则加回去），商左移，末置位不断赋 1 或 0<br />\n 除法的改进版相比于乘法余数向左移（最终存储值)，这是因为控制单元在右边，通过右边产生 0 或 1 来出现商。<br />\n有符号数余数的设置要让商的绝对值不变化，余数应该与被除数的符号相同 (笔者猜测)。</p>\n<blockquote>\n<p>忽略了除数位 0，忽略溢出，通过 hi 和 lo 来判断吧（mflo 和 mfhi）注意余数是 hi</p>\n</blockquote>\n<h2 id=\"浮点运算\"><a class=\"anchor\" href=\"#浮点运算\">#</a> 浮点运算</h2>\n<p>科学计数法，没有前导零且小数点左边只有一位有效位叫做规格化数。<br />\n二进制数科学计数法<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1.0</mn><mo>∗</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">1.0*2^{-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">.</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> 浮点数表示<br />\n浮点表示：<br />\n注意这个尾数第一位表示的是 0.5，也就是前导位 1 是自带的</p>\n<blockquote>\n<p>前导位 0 的表示是通过把指数位设为 0 来表示的，0 这个数是所有位都为 0 表示<br />\n无穷大数设置指数位最大，尾数为 0，尾数不为 0 则为 NaN（非数（由 0/0 或无穷减无穷产生））</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>s</th>\n<th>exponent</th>\n<th>fraction</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1 位</td>\n<td>8 位</td>\n<td>23 位</td>\n</tr>\n</tbody>\n</table>\n<p>还是可能会出现上溢，在指数级容纳不下，还有下溢，就是指数级 10^(-38) 达不到的地方<br />\n double (两个字大小) 表示，</p>\n<table>\n<thead>\n<tr>\n<th>s</th>\n<th>exponent</th>\n<th>fraction</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1 位</td>\n<td>11 位</td>\n<td>52 位</td>\n</tr>\n</tbody>\n</table>\n<p>精度到达<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>308</mn></msup></mrow><annotation encoding=\"application/x-tex\">2*10^{308}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">0</span><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span></span></span></span><br />\n 采用带偏阶（或移码）记数法（biased notation). 意思是指数的真实值是减去这个 bias，单精度 bias 是 127，双精度是 1023，为啥向下取整我不知道（可能是 255 表示无穷吧，1-254 的指数才是正常指数，但是你看这张图多奇怪<br />\n！[[Pasted image 20241220195351.png]])<br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo>−</mo><mn>0.7</mn><msub><mn>5</mn><mn>10</mn></msub></mrow><annotation encoding=\"application/x-tex\">-0.75_{10}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.79444em;vertical-align:-0.15em;\"></span><span class=\"mord\">−</span><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\">7</span><span class=\"mord\"><span class=\"mord\">5</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的单精度格式为 1 01111110 10000000000000000000000</p>\n<h4 id=\"浮点加法\"><a class=\"anchor\" href=\"#浮点加法\">#</a> 浮点加法</h4>\n<p 10=\"\">会出现保留位的说法，先将指数小的向指数大的对齐，然后舍去到大数所能包容的有效位，有效位此时是规格化科学计数法的有效位，规格化后检查上溢和下溢 (-126~127 其实就是有效指数位)，然后舍成有效位，再规格化，具体计算看 151 和 152 页，注意写的时候注意写清下标是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mrow></mrow><mn>2</mn></msub></mrow><annotation encoding=\"application/x-tex\">_{2}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.45110799999999995em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 还是_</p>\n<h3 id=\"浮点乘法\"><a class=\"anchor\" href=\"#浮点乘法\">#</a> 浮点乘法</h3>\n<p>较为简单，自行看 p155，当然尾数乘法就是乘出来的最高位肯定是前导 1</p>\n<h3 id=\"浮点数指令\"><a class=\"anchor\" href=\"#浮点数指令\">#</a> 浮点数指令</h3>\n<p>add.s（单精度加) add.d（双精度加)<br />\nsub.s sub.d<br />\nmul.s mul.d 莫名没了个 t 也是坑人<br />\n div.s div.d<br />\nc.x.s c.x.s 就是比较 x 可以是 eq、neq、lt、le、gt、ge 感觉不会考，不用 rd 来接受返回值的操作，值存储在浮点标志中<br />\n bclt 和 bclf 真分支跳转和假分支跳转 浮点标志是 c.x.s 这些给出的<br />\n有 $f0, $f1, $f2 这类浮点寄存器，两个寄存器构成一个双精度 0 和 1 构成一个（偶 - 奇搭配) 还有 lwcl 和 swcl ，写到这我就忘了汇编的是啥了。。。。<br />\n注意没有浮点常数，一般直接常数放在内存取出来</p>\n<h3 id=\"浮点数算术精度\"><a class=\"anchor\" href=\"#浮点数算术精度\">#</a> 浮点数算术精度</h3>\n<p>保护位 (guard) 舍入位 (round) 保护位在前舍入位在后<br />\n保护位原来在这里，有几种舍入策略，round up ,round down ,truncation, 向最近偶数舍入</p>\n<ul>\n<li>保护位舍入，就是看有效位后面两位，0-49 舍去，51-99 入位。<br />\n浮点数精确性由尾数最低位的单位 (ulp)(unit in the last place) 给出，这个方法保证误差在半个 ulp 以内<br />\n粘贴位就是在舍入位后多一位，表示舍入位后是否全为 0，如果不全为 0，则置 1，保护位和舍入位<br />\n运算时这些位都会用到，最后一步才会真正舍去，详情见 p163</li>\n</ul>\n<h1 id=\"处理器\"><a class=\"anchor\" href=\"#处理器\">#</a> 处理器</h1>\n<p>存储访问指令和算术逻辑指令分支指令通过 ALU 实现<br />\n图得看 p183<br />\n 选择不同来源数据使用多路选择器（multiplexor)。例如决定 pc+4 还是分支目的地址<br />\n控制单元 (control unit)，给出 multiplexor 的选择信号<br />\n mips 数据通路包含两种单元：处理数据值的单元和存储状态的单元<br />\n处理数据值的单元是组合逻辑单元 (conbinational element), 输出只取决于当前输入。ALU 就是这类。<br />\n有内部存储功能的单元是状态单元 (state element) 也叫时序 (sequential) 部件，指令存储器、数据存储器、寄存器都是状态单元。一个状态单元至少有两个输入和一个输出。两个输入时待写入数据值和决定何时写入的时钟信号。</p>\n<h3 id=\"时钟策略\"><a class=\"anchor\" href=\"#时钟策略\">#</a> 时钟策略</h3>\n<p>采用边沿触发时钟 (edge-triggered clocking) 方法，书上假定上升沿发生变化（也可以下降沿）。 <code>|-|_</code> 这个横线是上划线。。。, 若某状态单元在时钟边沿进行写入，那可以忽略控制信号。如果不是每个周期都进行修改，则要显式的写控制信号。写控制信号和时钟信号都是输入信号，必须稳定等到时钟沿到来才改变状态。<br />\n有效 (asserted) 表示信号为逻辑高或真<br />\n无效 (deasserted) 表示信号为逻辑低或假</p>\n<h3 id=\"建立数据通路\"><a class=\"anchor\" href=\"#建立数据通路\">#</a> 建立数据通路</h3>\n<p>指令存储器，程序计数器，ALU，加法器（计算 pc，可以用 ALU）<br />\n寄存器堆存放 32 个传统用寄存器。地址偏移还要有个 sign-extend 单元来符号拓展<br />\n注意寄存器堆的输入信号和输出信号同时变换，所以读出同一时钟周期是不可能相互影响到的，所以读出的只会是写入之前的数据，不过可以在末尾读入，也就是一个时钟周期读写嘛</p>\n<p>计算分支指令的基地址是下一条指令的地址。<br />\n分支发生 branch taken 分支未发生 branch not taken<br />\n 跳转指令将 26 位左移 2 位后，代替 PC 的低 28 位。<br />\nALU 的控制信号是 4 位，控制单元的输入是 func 字段和 2 位的 ALUop，op 决定操作是由 00 (加法)、01 (beq 的减法)、10（指令的 func 字段)（R 型指令的选择）来决定操作，输出的就是上面讲的 4 位控制信号。6 种组合看 p193。</p>\n<h4 id=\"七个1位控制信号\"><a class=\"anchor\" href=\"#七个1位控制信号\">#</a> 七个 1 位控制信号</h4>\n<p>对着书上的图 p196 看看位置</p>\n<table>\n<thead>\n<tr>\n<th>信号名</th>\n<th>置无效时（0）效果</th>\n<th>置有效时（1）的效果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>RegDst</td>\n<td>写入寄存器时，目标寄存器编号来自 rt 字段</td>\n<td>写入寄存器时，目标寄存器编号是 rd 字段 (15:11)</td>\n</tr>\n<tr>\n<td>RegWrite</td>\n<td>无</td>\n<td>数据写入由写入寄存器输入端口指定的寄存器</td>\n</tr>\n<tr>\n<td>ALUSrc</td>\n<td>第二个 ALU 操作数来自寄存器堆第二个输出</td>\n<td>第二个 ALU 操作数是指令低 16 位的符号拓展</td>\n</tr>\n<tr>\n<td>PCSrc</td>\n<td>PC 使用 PC+4 更新</td>\n<td>PC 使用分支目标地址更新</td>\n</tr>\n<tr>\n<td>MemRead</td>\n<td>无</td>\n<td>输入地址对应的数据输出到读数据输出端口</td>\n</tr>\n<tr>\n<td>MemWrite</td>\n<td>无</td>\n<td>将写入数据输入端的数据写入地址输入端指定的存储单元</td>\n</tr>\n<tr>\n<td>MemtoReg</td>\n<td>写入寄存器数据来自于 ALU</td>\n<td>写入寄存器数据来自数据存储器</td>\n</tr>\n</tbody>\n</table>\n<p>控制信号的输入和输出看 p200-201</p>\n<h3 id=\"流水线\"><a class=\"anchor\" href=\"#流水线\">#</a> 流水线</h3>\n<p><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>指令执行时</mtext><msub><mtext>间</mtext><mtext>流水线</mtext></msub><mo>=</mo><mfrac><mrow><mtext>指令执行时</mtext><msub><mtext>间</mtext><mtext>非流水线</mtext></msub></mrow><mtext>流水线级数</mtext></mfrac></mrow><annotation encoding=\"application/x-tex\">指令执行时间_{流水线}=\\frac{指令执行时间_{非流水线}}{流水线级数}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord cjk_fallback\">指</span><span class=\"mord cjk_fallback\">令</span><span class=\"mord cjk_fallback\">执</span><span class=\"mord cjk_fallback\">行</span><span class=\"mord cjk_fallback\">时</span><span class=\"mord\"><span class=\"mord cjk_fallback\">间</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">流</span><span class=\"mord cjk_fallback mtight\">水</span><span class=\"mord cjk_fallback mtight\">线</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.2336359999999997em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8886359999999999em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">流</span><span class=\"mord cjk_fallback mtight\">水</span><span class=\"mord cjk_fallback mtight\">线</span><span class=\"mord cjk_fallback mtight\">级</span><span class=\"mord cjk_fallback mtight\">数</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.410305em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">指</span><span class=\"mord cjk_fallback mtight\">令</span><span class=\"mord cjk_fallback mtight\">执</span><span class=\"mord cjk_fallback mtight\">行</span><span class=\"mord cjk_fallback mtight\">时</span><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">间</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.3567071428571427em;margin-left:0em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.5em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">非</span><span class=\"mord cjk_fallback mtight\">流</span><span class=\"mord cjk_fallback mtight\">水</span><span class=\"mord cjk_fallback mtight\">线</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.14329285714285717em;\"><span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> 这个公式要在程序指令多时成立</p>\n<h3 id=\"面向流水线的设计\"><a class=\"anchor\" href=\"#面向流水线的设计\">#</a> 面向流水线的设计</h3>\n<p>为什么 mips 适合流水线:</p>\n<ul>\n<li>所有指令长度相同</li>\n<li>指令格式少，并且每条指令寄存器字段位置相同 (对称性），确定取指类型同时开始读取寄存器堆</li>\n<li>存储器操作数仅出现在 load 和 store，不可以直接访问内存</li>\n<li>所有操作数都必须在存储器对齐</li>\n</ul>\n<h4 id=\"数据冒险\"><a class=\"anchor\" href=\"#数据冒险\">#</a> 数据冒险</h4>\n<p>有三种冒险类型</p>\n<ol>\n<li>结构冒险：就是两条指令同时访问一个硬件</li>\n<li>数据冒险：取数指令取的数是之前的目标，通过增加硬件来提前得到缺少运算项，这个方法叫做前推 (forwarding) 或者叫做旁路 (bypassing)<br />\n 取数 - 使用型数据冒险 (load-use data hazard) 上一个指令 lw，下一个指令就用，这会导致<br />\n流水线阻塞（pipeline stall) 或叫做空泡 (bubble)</li>\n<li>控制冒险：决策依赖于一条指令的结果，而其他指令正在执行。就是要看第一条指令结果再决定是否进行下一步，其实就是 beq 是否跳转<br />\n解决方法是：阻塞（stall) 或者预测（predict)(通常预测分支不发生如果真发生的话会产生阻塞) 或延迟决定（就是用不相关的指令先搪塞着（调节指令顺序））</li>\n</ol>\n<blockquote>\n<p>阻塞对性能影响可以看 p210</p>\n</blockquote>\n<h4 id=\"流水线小结\"><a class=\"anchor\" href=\"#流水线小结\">#</a> 流水线小结</h4>\n<p>流水线不能减少单条指令执行时间（也叫延迟（latency）），流水线指示提高了吞吐率（throughput)。</p>\n<h3 id=\"流水线数据通路与控制\"><a class=\"anchor\" href=\"#流水线数据通路与控制\">#</a> 流水线数据通路与控制</h3>\n<p>数据通路有五个部分：</p>\n<ul>\n<li>IF：取指令</li>\n<li>ID：指令译码，读寄存器堆</li>\n<li>EX: 执行或计算地址</li>\n<li>MEM：访问数据存储器</li>\n<li>WB：写回<br />\n每两个阶段中间有一个流水线寄存器，IF/ID 这种，store 指令最后 WB 啥也不做，但是也没有优化空间。<br />\n每一个逻辑单元都只能在一个流水线中使用，否则会产生结构冒险，因此这些单元及其控制可以和一个流水级相关联<br />\n流水线可以看 p216-220<br />\n 多时钟周期图在 p223，不过不知道要不要画。。。，单时钟周期就是电路图上面加了个表，在 p224</li>\n</ul>\n<h4 id=\"流水线数据冒险旁路与阻塞\"><a class=\"anchor\" href=\"#流水线数据冒险旁路与阻塞\">#</a> 流水线数据冒险：旁路与阻塞</h4>\n<p>sub 指令的结果被下一条指令用到，旁路条件:<br />\n1a. EX/MEM.RigisterRd=ID/EX.RegisterRs（Rd 不等于 0&amp;&amp;regwrite=1）<br />\n1b.EX/MEM.RigisterRd=ID/EX.RegisterRt<br />\n2a. MEM/WB.RigisterRd=ID/EX.RegisterRs<br />\n2b. MEM/WB.RigisterRd=ID/EX.RegisterRd<br />\n 这个表明流水线下 sub 这类指令会影响下面两条指令 1 和 2 的区别在于下一条还是下面第二条指令<br />\n为了这个旁路，我们亲爱的 ID/EX 流水线寄存器还多了个 5 位的 rs 字段，之前是直接保存 rs 的值的，现在 key 也要保存了。<br />\n这个具体操作还是得看 p231，信号看 p233</p>\n<table>\n<thead>\n<tr>\n<th>EX 冒险</th>\n<th>MEM 冒险</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1.a:forwardA=10</td>\n<td>2.a:ForwardA=01</td>\n</tr>\n<tr>\n<td>1.bfowardB=10</td>\n<td>2.b:ForwardB=01</td>\n</tr>\n</tbody>\n</table>\n<p>A 和 B 其实是第一（二）个 ALU 操作数来源于哪里的问题，00 代表来自寄存器堆。<br />\n如果出现 add s1，s1，1；add s1，s1，1；add s1，s1，1 时，从 MEM/WB 去取，详情看 P233，因为 MEM 级是最新的，EX/MEM 最新的还没写进去。<br />\n# 问了老师可能书上是错的，因为 EX 是最新的</p>\n<blockquote>\n<p>sw 和 lw 的冒险看 ppt，不过只能避免一次阻塞，也就是说有冲突必有一空泡</p>\n</blockquote>\n<h3 id=\"冒险与阻塞\"><a class=\"anchor\" href=\"#冒险与阻塞\">#</a> 冒险与阻塞</h3>\n<p>load 指令必须阻塞一个时钟周期，这个检测叫冒险检测，检测如下：<br />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(ID/EX.MemRead and ((ID/EX.Rt=IF/IF.Rs)or(ID/EX.Rt=IF/ID.Rt)))</span><br><span class=\"line\">stall the pipeline</span><br></pre></td></tr></table></figure><br />\n 人话就是如果读的话，然后 ID/EX 的存储寄存器等于下一指令的运算寄存器就停。<br />\n阻塞的办法就是保持 PC 和 IF/ID 流水线寄存器不变。<br />\nEX 开始的部分都是 nop，将 EX、MEM 和 WB 级的 9 个控制信号清除（置 0）。方法是将 ID/EX 流水线寄存器的这三个控制信号置为 0。<br />\n这导致这个指令 IF 级在第三个时钟周期，ID 级在第五个时钟周期</p>\n<h3 id=\"控制冒险或分支冒险\"><a class=\"anchor\" href=\"#控制冒险或分支冒险\">#</a> 控制冒险或分支冒险</h3>\n<p>看 p238，</p>\n<h3 id=\"假定分支不发生\"><a class=\"anchor\" href=\"#假定分支不发生\">#</a> 假定分支不发生</h3>\n<p>丢弃指令就是把控制信号置 0，要改变 IF、ID 和 EX 级的三条控制信号，而不是单单 ID 级的</p>\n<h3 id=\"缩短分支延迟\"><a class=\"anchor\" href=\"#缩短分支延迟\">#</a> 缩短分支延迟</h3>\n<p>将分支执行到 ID 级，通过逻辑门的异或来判断。<br />\n为了在 IF 级清除指令，我们加入 IF.Flush 的控制信号，将 IF/ID 流水线寄存器的指令字段置为 0</p>\n<h3 id=\"动态分支预测dynamic-branch-prediction\"><a class=\"anchor\" href=\"#动态分支预测dynamic-branch-prediction\">#</a> 动态分支预测 (dynamic branch prediction)</h3>\n<p>采用分支预测缓存 (cache) 或叫做分支历史记录表 (history table), 一位数据表示最近是否发生，但是一个总是发生分支第一次和最后一次会错误。<br />\n因而采用两位预测位，具体实现看 p241-242</p>\n<h2 id=\"异常\"><a class=\"anchor\" href=\"#异常\">#</a> 异常</h2>\n<p>控制最难部分之一是实现异常和中断。很多操作系统不区分异常和中断，但 mips 中异常是任何意外的改变，无论内外，中断是由外部引起的事件。具体看 p245 的分类<br />\n I/O 设备请求错误就是中断，像算法溢出之类就是异常（不过感觉不是很清楚）</p>\n<p>异常发生时在 EPC (exception pc) 保存出错指令的地址，将控制权转交给操作系统的特定地址。两种方法表示异常原因，一个是 Cause 寄存器，一个是向量中断（vectored interrupt），在向量中断中，控制权转移到由异常原因决定的地址处。<br />\n多个异常在同一时钟周期同时发生先处理最早发生的异常，注意此处 EX 的异常与下一指令的 ID 异常为同一时钟周期，而不是 IF</p>\n<h2 id=\"指令级并行\"><a class=\"anchor\" href=\"#指令级并行\">#</a> 指令级并行</h2>\n<h3 id=\"多发射multiple-issue\"><a class=\"anchor\" href=\"#多发射multiple-issue\">#</a> 多发射（multiple issue）</h3>\n<p>每一阶段有多个状态单元和组合逻辑单元<br />\n分为静态多发射（static）：决策在编译阶段做出 和动态多发射：决策在执行阶段做出</p>\n<h4 id=\"推测speculation\"><a class=\"anchor\" href=\"#推测speculation\">#</a> 推测（speculation）</h4>\n<p>交换指令顺序，可能会导致原本不异常的地方异常。</p>\n<h4 id=\"静态多发射处理器\"><a class=\"anchor\" href=\"#静态多发射处理器\">#</a> 静态多发射处理器</h4>\n<p>使用编译器帮助打包多条指令并处理冒险。在给定时钟周期发射多条指令，也称为发射包（issue packet). 可将发社保看作允许同时执行多个操作的一条指令：超长指令字（Very Long Instruction Word，VLIW)<br />\n 一般是双发射。（两个指令一次打包。）组合逻辑单元基本都要加倍<br />\n详细过程看 p252<br />\n 这个编译器又能处理一个包的各种冒险 (不包括包与包之间的)，又要减少 load 的使用延迟对打包后的 ALU 的影响，真强大。<br />\n答题看 p253-254</p>\n<p>另一种更高性能编译技术是循环展开 (loop unrolling)<br />\n 此时需要寄存器重命名来消除一些虚假的数据相关，也叫反相关（antidependence)，或者名字相关</p>\n<h4 id=\"动态多发射处理器\"><a class=\"anchor\" href=\"#动态多发射处理器\">#</a> 动态多发射处理器</h4>\n<p>也叫超标量处理器（superscalar)<br />\n 采用动态流水线调度 (dynamic pipeline scheduling)</p>\n<h2 id=\"能耗效率\"><a class=\"anchor\" href=\"#能耗效率\">#</a> 能耗效率</h2>\n<p>每块芯片集成多个处理器，要比复杂处理器功耗要好。</p>\n<h1 id=\"存储器存储结构\"><a class=\"anchor\" href=\"#存储器存储结构\">#</a> 存储器存储结构</h1>\n<p>局部性原理：</p>\n<ul>\n<li>时间局部性 (temporal locality): 某个数据时间上访问间隔短</li>\n<li>空间局部性（spatial locality）：空间上间距短<br />\n用局部性原理组织成存储器层次结构<br />\n高级存储器靠近处理器较贵。<br />\n我们将两级层次结构中存储信息的最小单元称为块（block) 或行（line）<br />\n如果高层存储器没有找到所需数据那么这次数据请求称为一次缺失。<br />\n命中率（hit rate）<br />\n缺失率（1 - 命中率）<br />\nhit time<br />\nmiss penalty<br />\ncache 由 SRAM (静态随机存取存储器) 实现<br />\n memory 由 DRAM 实现</li>\n</ul>\n<h3 id=\"sram\"><a class=\"anchor\" href=\"#sram\">#</a> SRAM</h3>\n<p>空闲模式下需要最小功率保持电荷，不需要刷新，对任何数据的访问时间是固定的，供电状态下数值不变</p>\n<h3 id=\"dram\"><a class=\"anchor\" href=\"#dram\">#</a> DRAM</h3>\n<p>使用电容保存电荷，因为电容保存，所以不能长久地保持数据，需要周期性地刷新，这也是动态的原因</p>\n<p>有 DDR（双数据速率）这个型号。这个是时钟上升下降沿都输入输出信息<br />\n DDR4 这种可对 4 个 bank 发送一个地址同时访问，用轮转方式对这四个 bank 访问可以提供四倍带宽，也称地址交叉<br />\n书上讲的不明所以，建议看 ppt</p>\n<h3 id=\"闪存\"><a class=\"anchor\" href=\"#闪存\">#</a> 闪存</h3>\n<p>写操作会产生损耗，所以会有控制器将已经很多次地块重映射到写入次数较少的块中。俗称损耗均衡 (wear leveling) 技术</p>\n<h3 id=\"磁盘存储器\"><a class=\"anchor\" href=\"#磁盘存储器\">#</a> 磁盘存储器</h3>\n<p>一个磁盘具有一组瓷盘片，绕轴每分钟转动近 10000 圈。每层表面有一个包含小型电磁线圈的读写磁头。</p>\n<p>每个磁盘表面划分为同心圆盘，称为磁道，每个磁道被划分为存储信息的扇区。扇区容量 0.5KiB~4Kib.<br />\n 访问数据三步骤：</p>\n<ul>\n<li>寻道。找到适当磁道</li>\n<li>等待要访问扇区转动到读写头下面，等待时间称为旋转延迟</li>\n<li>传输时间<br />\n传输时间计算得看 ppt</li>\n</ul>\n<h2 id=\"cache基本原理\"><a class=\"anchor\" href=\"#cache基本原理\">#</a> cache 基本原理</h2>\n<p>cache 大小不含标记位和有效位，具体算大小位数看 p292. 标记字段大小是 32-n（块的个数）-m（一块中字的个数）-2（默认字的字节偏移量）<br />\ncache 的有效大小位数<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>∗</mo><msup><mn>2</mn><mi>m</mi></msup><mo>∗</mo><mn>32</mn></mrow><annotation encoding=\"application/x-tex\">2^{n}*2^{m}*32</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">m</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">2</span></span></span></span><br />\n 总位数等于<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>∗</mo><mo stretchy=\"false\">(</mo><mtext>块大小</mtext><mo>+</mo><mtext>标记字段大小</mtext><mo>+</mo><mtext>有效位字段大小</mtext><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">2^{n}*(块大小+标记字段大小+有效位字段大小)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord cjk_fallback\">块</span><span class=\"mord cjk_fallback\">大</span><span class=\"mord cjk_fallback\">小</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord cjk_fallback\">标</span><span class=\"mord cjk_fallback\">记</span><span class=\"mord cjk_fallback\">字</span><span class=\"mord cjk_fallback\">段</span><span class=\"mord cjk_fallback\">大</span><span class=\"mord cjk_fallback\">小</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord cjk_fallback\">有</span><span class=\"mord cjk_fallback\">效</span><span class=\"mord cjk_fallback\">位</span><span class=\"mord cjk_fallback\">字</span><span class=\"mord cjk_fallback\">段</span><span class=\"mord cjk_fallback\">大</span><span class=\"mord cjk_fallback\">小</span><span class=\"mclose\">)</span></span></span></span> 别忘了这个有效位 1 位<br />\n地址映射看 p293，是向下取整。</p>\n<p>如果仅仅增加块大小，会导致 miss penalty 的增加。<br />\n解决方法就是加快传输速率，减少这个延迟可以隐藏一些传输时间，最简单方法就是提前重启（early restart），即块中所需的字一旦返回就马上继续执行。不过这个问题在于字的分布不确定，同时若下一条指令请求另一块中的字，那么处理器就无法访问 cache。还有一种方法是关键字有限，在 p295；</p>\n<h4 id=\"cache缺失处理cache-miss\"><a class=\"anchor\" href=\"#cache缺失处理cache-miss\">#</a> cache 缺失处理（cache miss）</h4>\n<p>cache 缺失处理由两部分共同完成：处理器控制单元，以及一个进行初始化主存访问和重新填充 cache 的独立控制器。cache 缺失引起流水线阻塞，阻塞整个处理器，冻结所有内容。我们假定顺序执行处理器。</p>\n<blockquote>\n<p>乱序执行（out-of-order) 处理器在等待缺失处理同时仍能执行部分指令</p>\n</blockquote>\n<p>指令 cache 缺失处理步骤：</p>\n<ol>\n<li>PC 原始值 (PC-4) 送到存储器中</li>\n<li>通知主存执行一次读操作，并等待主存访问完成</li>\n<li>写 cache 项，将从主存读回数据写入 cache 存放数据的部分。并将地址高位写入标记字段，设置有效位。</li>\n<li>重启执行执行第一步，重新取指，这次该指令在 cache 中.<br />\n 数据缺失同理。</li>\n</ol>\n<h4 id=\"写操作处理\"><a class=\"anchor\" href=\"#写操作处理\">#</a> 写操作处理</h4>\n<p>为保持 cache 和 memory 的一致性，我们采用两种办法:</p>\n<ul>\n<li>write-through（写直达）直接将更改的字写入 cache 和 memory 中\n<ul>\n<li>可以使用 (write buffer), 如果存储器完成写操作速度慢于产生写操作速度，那么没有作用。</li>\n</ul>\n</li>\n<li>write-back (写回)，被替换时才要写道较低层存储结构。下面各种时 cache 缺失策略</li>\n<li>写分配，在 cache 中分配一块</li>\n<li>写不分配，只更新主存，不写入 cache 中。<br />\n写直达比写回安全，因为写直达有内存备份，而写回没有，所以写回必须得判断 cache 是否命中再完成写操作，而写直达不需要，因为缺失就再次更改 cache。</li>\n</ul>\n<h3 id=\"小结\"><a class=\"anchor\" href=\"#小结\">#</a> 小结</h3>\n<p>cache 性能可通过增加主存带宽：增加存储器位宽和交叉存取。<br />\n计算性能看 p301<br />\n 平均存储器访问时间 (Average Memory Access Time,AMAT)：<br />\nAMAT = 命中时间 + 缺失率 <code>*</code>  缺失代价</p>\n<h3 id=\"灵活放置块\"><a class=\"anchor\" href=\"#灵活放置块\">#</a> 灵活放置块</h3>\n<p>全相联：块可以放在 cache 任何位置，适用块数较少的 cache<br />\n 组相联：介于直接映射和全相联之间。每个块有 n 个可放位置叫做 n 路组相联 cache。（n 也称为相联度）<br />\n降低缺失率但是增加了命中时间。<br />\n采用更换最少被访问的块的规则更新组。<br />\n相同容量和相同块大小下，相联度其实也就一路到二路好点，缺失率降低了 15%，其余基本改善空间不大。</p>\n<h4 id=\"在组相联中找cache块\"><a class=\"anchor\" href=\"#在组相联中找cache块\">#</a> 在组相联中找 cache 块</h4>\n<table>\n<thead>\n<tr>\n<th>标记</th>\n<th>索引</th>\n<th>块偏移</th>\n</tr>\n</thead>\n</table>\n<p>这个是查找的信息。每组采用并行检索标记号。需要 n 个比较器和一个 n 选 1 的多路选择器。</p>\n<h4 id=\"替换块\"><a class=\"anchor\" href=\"#替换块\">#</a> 替换块</h4>\n<p>采用 LRU（Least recently used）法，最久没有被使用的块。<br />\n组相联 n 越大，标记字段大小越大，因为索引其实不占 cache 大小。</p>\n<h4 id=\"使用多级cache减少损失代价\"><a class=\"anchor\" href=\"#使用多级cache减少损失代价\">#</a> 使用多级 cache 减少损失代价</h4>\n<p>采用 L1 和 L2cache，多级 cache 性能看 p307<br />\n 主存缺失代价为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mn>100</mn><mi>n</mi><mi>s</mi></mrow><mrow><mn>0.25</mn><mfrac><mrow><mi>n</mi><mi>s</mi></mrow><mtext>时钟周期</mtext></mfrac></mrow></mfrac><mo>=</mo><mn>400</mn><mtext>个时钟周期</mtext></mrow><annotation encoding=\"application/x-tex\">\\frac{100ns}{0.25\\frac{ns}{时钟周期}}=400个时钟周期</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.4309079999999998em;vertical-align:-0.5857999999999999em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.845108em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">0</span><span class=\"mord mtight\">.</span><span class=\"mord mtight\">2</span><span class=\"mord mtight\">5</span><span class=\"mord mtight\"><span class=\"mopen nulldelimiter sizing reset-size3 size6\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6915428571428572em;\"><span style=\"top:-2.656em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord cjk_fallback mtight\">时</span><span class=\"mord cjk_fallback mtight\">钟</span><span class=\"mord cjk_fallback mtight\">周</span><span class=\"mord cjk_fallback mtight\">期</span></span></span></span><span style=\"top:-3.2255000000000003em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line mtight\" style=\"border-bottom-width:0.049em;\"></span></span><span style=\"top:-3.384em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">s</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.344em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter sizing reset-size3 size6\"></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span><span class=\"mord mtight\">0</span><span class=\"mord mathnormal mtight\">n</span><span class=\"mord mathnormal mtight\">s</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5857999999999999em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">4</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord cjk_fallback\">个</span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">钟</span><span class=\"mord cjk_fallback\">周</span><span class=\"mord cjk_fallback\">期</span></span></span></span> 这种形式<br />\n L1cache 致力于减少命中时间，L2cache 致力于改善缺失率<br />\n快排比基数排序要快因为 cache 缺失率低。</p>\n<p>L2cache 的局部缺失率挺高的，但是全局缺失率低。</p>\n<h2 id=\"可信性问题\"><a class=\"anchor\" href=\"#可信性问题\">#</a> 可信性问题</h2>\n<p>冗余技术。<br />\n失效定义：两种状态：</p>\n<ul>\n<li>服务完成：交付的服务于需求不符。</li>\n<li>服务中断：交付的服务与需求不符。<br />\n失效导致状态 1 到状态 2 的转换。状态 2 到状态 1 称为恢复。<br />\n平均无故障时间（Mean Time To Failure，MTTF）是一个可靠性度量方法。年失效率（Annual Failure Rate，AFR）指在给定 MTTF 下，一年内预期的器件失效比例。<br />\n服务中断用平均修复时间（Mean Time To Repair，MTTR) 来度量。平均失效间隔（Mean time Between Failure，MTBF）=MTTF+MTTR。<br />\n可用性指系统正常工作时间连续两次服务中断间隔时间中所占的比例：<br />\n可用性 =<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mrow><mi>M</mi><mi>T</mi><mi>T</mi><mi>F</mi></mrow><mrow><mi>M</mi><mi>T</mi><mi>T</mi><mi>F</mi><mo>+</mo><mi>M</mi><mi>T</mi><mi>T</mi><mi>R</mi></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{MTTF}{MTTF+MTTR}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.275662em;vertical-align:-0.403331em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.872331em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">F</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.403331em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span><br />\n 用术语故障（fault）来表示一个器件的失效，用三种方式可以提高系统的 MTTF：</li>\n<li>故障避免技术：合理构建系统</li>\n<li>故障容忍技术：荣誉措施</li>\n<li>故障预测技术：在器件失效前进行替换</li>\n</ul>\n<h2 id=\"纠正一位错-检测两位错的汉明编码secded\"><a class=\"anchor\" href=\"#纠正一位错-检测两位错的汉明编码secded\">#</a> 纠正一位错、检测两位错的汉明编码（SEC/DED)</h2>\n<p>parity 校验码检测 1 位错误，称为 1 位错误检测编码（1 表示奇数，0 表示偶数）。汉明纠错码（Hamming Error Correcting Code，ECC）。<br />\n我们采用额外的校验位确定单个错误的位置。具体看 p315<br />\n 校验位 1、2、4、8（编号二进制第 logn+1 位为 1）。此外，我们可以通过增加 1 位来导致码字中的最小汉明距离变到 4。可以纠正 1 位错检测 2 位错。这个增加的校验位取决于前面的奇偶纠错校验位和原数据位的奇偶产生的偶校验<br />\n以下是出现的四种情况（H 位纠错码组的奇偶性，全局奇偶校验位为 p）：</p>\n<ol>\n<li>H 为偶，p 为偶，无错误发生</li>\n<li>H 为奇，P 为奇，出现一个可纠正错误。</li>\n<li>H 为偶，P 为奇，p 错了</li>\n<li>H 为奇，p 为偶，常出现两位错<br />\n纠错位<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>p</mi></msup><mo>&gt;</mo><mo>=</mo><mi>p</mi><mo>+</mo><mi>d</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^{p}&gt;=p+d+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.703492em;vertical-align:-0.0391em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7777700000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></li>\n</ol>\n<h2 id=\"虚拟机\"><a class=\"anchor\" href=\"#虚拟机\">#</a> 虚拟机</h2>\n<p>操作系统虚拟机能与硬件匹配。<br />\n支持虚拟机的软件称为虚拟机监视器 (Virtual Machine Monitor,VMM) 或者管理程序 (hypervisor):VMM 是虚拟机技术核心。底层硬件平台叫主机（host），其资源被客户端（guest）虚拟机共享。<br />\n虚拟机保护功能不错，同时，商业意义上，它也有其他两个重要优势：</p>\n<ul>\n<li>软件管理：提供一个可以运行完整软件栈的抽象</li>\n<li>硬件管理：允许独立软件栈在共享硬件的同时独立运行，合并了服务器的数量。<br />\n每个客户端只能达到用户级，VMM 能达到更高级，从而保证特权指令执行</li>\n</ul>\n<h3 id=\"虚拟存储器virtual-memory\"><a class=\"anchor\" href=\"#虚拟存储器virtual-memory\">#</a> 虚拟存储器（virtual memory）</h3>\n<p>虚拟存储器中，块称为页，访问缺失叫做缺页。虚拟地址，由软件和硬件结合转化为物理地址。<br />\n在虚拟存储器中，地址被划分为虚拟页号（virtual page number）和页偏移（page offset），页偏移与物理地址一致，在低位。缺页改进方法看 p321</p>\n<h3 id=\"页的存放和查找\"><a class=\"anchor\" href=\"#页的存放和查找\">#</a> 页的存放和查找</h3>\n<p>页表（page table），存放在主存中，用虚拟地址中的页号作为索引，这个页表位置由页表寄存器给出。每个虚拟机由一块页表</p>\n<p>页表每一 entry 都有一个有效位。由于页表表示了所有虚拟页映射，所以不用标志位。看 p324 这张图。</p>\n<p>如果虚拟也有效位无效，会出现缺页故障，那么内存要去硬盘找到该页。这个交换空间是在进程开始时在闪存或磁盘上创建的交换区 (swap space), 不管存在主存还是磁盘上，页大小相等。</p>\n<p>LRU 替换策略</p>\n<p>写回机制，替换时写回磁盘。页表中加个脏页。</p>\n<h3 id=\"加快地址转换tlb\"><a class=\"anchor\" href=\"#加快地址转换tlb\">#</a> 加快地址转换：TLB</h3>\n<p>cache 快表 (Translation-Lookaside Buffer,TLB),TLB 中由脏位和引用位等状态位。每次访问先在 TLB 查找虚拟页号。命中的话物理页号形成地址，引用位被置位，写操作还是设置脏位。TLB 缺失要判断时页缺失还是 TLB 缺失。引用位其实就是用来 LRU 的。<br />\nTLB 换项时将引用位和脏位换到页表里（写回操作在 TLB 缺失时再写，会很高效）<br />\nTLB 采用全相联，同时随机选择替换表项。<br />\n看 p330 和 ppt<br />\n 还有 p331</p>\n<p>虚拟地址索引 cache 块，标记 TLB，可以直接知道 cache 块中有没有所需内容。</p>\n<p>TLB 的写访问位能让一个恶意进程不能写另一个用户进程的地址空间，写访问位由 VMM 控制。<br />\n进程切换时，TLB 一定要切换成另一个表的表项。或者用进程标识符和任务标识符</p>\n<h3 id=\"处理tlb缺失和缺页\"><a class=\"anchor\" href=\"#处理tlb缺失和缺页\">#</a> 处理 TLB 缺失和缺页</h3>\n<ul>\n<li>页在主存，创建表项</li>\n<li>不在主存，控制权交给操作系统处理缺页<br />\n出现 TLB 缺失和缺页要使用异常机制，EPC 记录程序计数器的值<br />\n异常必须在同一时钟周期的末尾被判定。<br />\n使主存写控制线无效。<br />\n异常处理时禁止其他异常。<br />\n页缺失时被引用的页号被保存在 BADVaddr 的特殊寄存器里。<br />\nTLB 缺失表项插入过程看 p336，有点麻烦  处理时并不会检查表项是否有效，直接会插入。</li>\n</ul>\n<h3 id=\"小结-2\"><a class=\"anchor\" href=\"#小结-2\">#</a> 小结</h3>\n<p>虚拟存储器允许单个程序地址空间拓展到主存界限之外。增大 memory 的表面大小（apparent size)<br />\n 采用技术降低缺失率：</p>\n<ul>\n<li>增大页容量</li>\n<li>全相联</li>\n<li>LRU 和访问位之类技术决定选择替换哪一页</li>\n</ul>\n<h3 id=\"存储器框架\"><a class=\"anchor\" href=\"#存储器框架\">#</a> 存储器框架</h3>\n<p>cache 容量增加，相连度提高对性能改进作用很小，其余看 p339 吧，感觉没啥。<br />\n页表采用的是全相联全映射<br />\n cache 替换策略：相联度较高的采用随机法，较低的采用 LRU（近似实现）<br />\n写直达比写回好实现。缺失代价小：不用把整块写回更低级存储系统</p>\n<h3 id=\"3c模型\"><a class=\"anchor\" href=\"#3c模型\">#</a> 3C 模型</h3>\n<ul>\n<li>强制缺失（compulsory miss）也称冷启动 (cold-start miss)：<br />\n从未出现过的块的第一次访问缺失</li>\n<li>容量缺失 (capacity miss) ：cache 某个块被替换后再次访问的缺失</li>\n<li>冲突缺失（conflict miss）也称碰撞缺失 (collision miss)：<br />\n多个块竞争同一组，全相联不存在这个问题。<br />\n强制缺失可以增大块来解决<br />\n容量缺失增大容量<br />\n看 p343 的表</li>\n</ul>\n<h3 id=\"有限状态机控制简单的cache\"><a class=\"anchor\" href=\"#有限状态机控制简单的cache\">#</a> 有限状态机控制简单的 cache</h3>\n<p>有限状态机通常假定那些没有明确置为有效的信号设置为无效信号。有限状态机实现看 p345，由一个组合逻辑和一个保持当前状态的寄存器实现。称为阻塞性（blocking）cache。</p>\n<h3 id=\"一个简单cache控制器的有限状态机\"><a class=\"anchor\" href=\"#一个简单cache控制器的有限状态机\">#</a> 一个简单 cache 控制器的有限状态机</h3>\n<p>cache 控制器的 4 个状态:</p>\n<ul>\n<li>空闲：</li>\n<li>标记比较：</li>\n<li>写回：将 128 位的块写回存储器（DRAM 控制器通常是 128 位）</li>\n<li>分配：<br />\n懒得写了看 p346 吧，都要等待准备好信号。标记比较状态可以和 cache 访问分离，以及价格写缓冲可以改进时钟周期</li>\n</ul>\n<h3 id=\"cache一致性\"><a class=\"anchor\" href=\"#cache一致性\">#</a> cache 一致性</h3>\n<p>多核多处理器，多个处理器共享一个公共的物理地址空间。但是 cache 各自拥有<br />\n一致性和连贯性：</p>\n<ul>\n<li>单个 CPU 写后读的就是写过的</li>\n<li>一个写操作后其他 CPU 在一定间隔后可以得到写过的</li>\n<li>写操作是串行执行的，不会出现同时写入<br />\n实现一致性的基本方案：</li>\n<li>迁移（migration）：数据项移入本地 cache，这样可以不用访问共享寄存器</li>\n<li>复制（replication）：共享数据被同时读取时，cache 在本地对数据项做备份，减少读取竞争<br />\n cache 一致性协议：最常用的是监听 (snooping) 协议。cache 保留数据块共享状态的副本，不集中保存状态。所有 cache 控制器对广播介质（总线或者网络）进行监视或者监听，来确保是否由总线或交换机上的数据块副本。</li>\n</ul>\n<h4 id=\"监听协议\"><a class=\"anchor\" href=\"#监听协议\">#</a> 监听协议</h4>\n<p>写无效协议 (write invalidate protocol) 处理器写操作前令其他副本无效。此时其他处理器读时需要重新请求新的数据副本，这时仍有效的 CPU 数据副本就会响应。<br />\n不过写操作处理器要独占访问，采用 random rule。</p>\n<h2 id=\"io\"><a class=\"anchor\" href=\"#io\">#</a> I/O</h2>\n<p>打印机采用轮询（polling）方式，其他基本采用中断，较慢的情况下</p>\n<p>pdf<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL21lbW9yeW9mZmlzaC9tZW1vcnlvZmZpc2guZ2l0aHViLmlvL2Jsb2IvbWFzdGVyL3BkZnMvbWlwcy5wZGY=\"> 下载链接</span></p>\n",
            "tags": [
                "笔者是菜鸟，上课不记笔记，因而只有补天笔记了"
            ]
        }
    ]
}